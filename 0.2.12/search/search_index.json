{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmotech Acceleration library","text":"<p>Acceleration library for CosmoTech cloud based solution development</p>"},{"location":"#code-organisation","title":"Code organisation","text":"<p>In project root directory you'll find 4 main directories:</p> <ul> <li>CosmoTech_Acceleration_Library: containing all Cosmo Tech libraries to accelerate interaction with Cosmo Tech solutions</li> <li>data: a bunch of csv files on which samples are based</li> <li>samples: a bunch of python scripts to demonstrate how to use the library</li> <li>doc: for schema or specific documentation</li> </ul>"},{"location":"#accelerators","title":"Accelerators","text":"<p>TODO</p>"},{"location":"#modelops-library","title":"Modelops library","text":"<p>The aim of this library is to simplify the model accesses via python code.</p> <p>The library can be used by Data Scientists, Modelers, Developers, ...</p>"},{"location":"#utility-classes","title":"Utility classes","text":"<ul> <li><code>ModelImporter(host: str, port: int, name: str, version: int, graph_rotation:int = 1)</code> : will allow you to bulk import data from csv files with schema enforced (<code>samples/Modelops/Bulk_Import_from_CSV_with_schema.py</code>) or not (<code>samples/Modelops/Bulk_Import_from_CSV_without_schema.py</code>) (see documentation for further details)</li> <li><code>ModelExporter(host: str, port: int, name: str, version: int, export_dir: str = '/')</code> : will allow you to export data from a model cache instance</li> <li><code>ModelReader(host: str, port: int, name: str, version: int)</code> : will allow you to read data from a model cache instance (object returned)</li> <li><code>ModelWriter(host: str, port: int, name: str, version: int, graph_rotation:int = 1)</code> : will allow you to write data into a model instance</li> <li><code>ModelUtil</code> : a bunch of utilities to manipulate and facilitate interaction with model instance (result_set_to_json, print_query_result, ... )</li> <li><code>ModelMetadata</code>: will allow you to management graph metadata</li> </ul>"},{"location":"#how-to","title":"How-to","text":"<p><code>python setup.py install --user</code></p>"},{"location":"dependencies/","title":"List of dependencies","text":"<p>Azure connection requirements </p> <p>Modelops requirements </p> <p>Cosmotech specific requirements </p> <p>Other requirements </p> <p>Documentation generation </p>"},{"location":"references/SUMMARY/","title":"SUMMARY","text":"<ul> <li>References<ul> <li>Modelops<ul> <li>core<ul> <li>common<ul> <li>graph_handler</li> <li>redis_handler</li> <li>writer<ul> <li>CsvWriter</li> </ul> </li> </ul> </li> <li>utils<ul> <li>model_util</li> <li>tests<ul> <li>model_util_test</li> </ul> </li> </ul> </li> <li>io<ul> <li>model_reader</li> <li>model_metadata</li> <li>model_writer</li> <li>model_exporter</li> <li>model_importer</li> </ul> </li> <li>decorators<ul> <li>model_decorators</li> </ul> </li> </ul> </li> </ul> </li> <li>Accelerators<ul> <li>adx_wrapper</li> <li>csm_engine</li> <li>cosmo_api</li> <li>scenario_download<ul> <li>azure_function_main</li> <li>scenario_downloader</li> </ul> </li> <li>utils<ul> <li>multi_environment</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"references/Accelerators/adx_wrapper/","title":"CosmoTech_Acceleration_Library.Accelerators.adx_wrapper","text":""},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper","title":"<code>ADXQueriesWrapper</code>","text":"<p>Wrapping class to ADX</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>class ADXQueriesWrapper:\n\"\"\"\n    Wrapping class to ADX\n    \"\"\"\n\n    def __init__(self,\n                 database: str,\n                 cluster_url: Union[str, None] = None,\n                 ingest_url: Union[str, None] = None,\n                 cluster_name: Union[str, None] = None,\n                 cluster_region: Union[str, None] = None):\n\n        if cluster_name and cluster_region:\n            cluster_url = f\"https://{cluster_name}.{cluster_region}.kusto.windows.net\"\n            ingest_url = f\"https://ingest-{cluster_name}.{cluster_region}.kusto.windows.net\"\n\n        try:\n            az_client_id = os.environ['AZURE_CLIENT_ID']\n            az_client_secret = os.environ['AZURE_CLIENT_SECRET']\n            az_tenant_id = os.environ['AZURE_TENANT_ID']\n\n            self.cluster_kcsb = KustoConnectionStringBuilder.with_aad_application_key_authentication(cluster_url,\n                                                                                                     az_client_id,\n                                                                                                     az_client_secret,\n                                                                                                     az_tenant_id)\n            self.ingest_kcsb = KustoConnectionStringBuilder.with_aad_application_key_authentication(ingest_url,\n                                                                                                    az_client_id,\n                                                                                                    az_client_secret,\n                                                                                                    az_tenant_id)\n        except KeyError:\n            self.cluster_kcsb = KustoConnectionStringBuilder.with_az_cli_authentication(cluster_url)\n            self.ingest_kcsb = KustoConnectionStringBuilder.with_az_cli_authentication(ingest_url)\n        self.kusto_client = KustoClient(self.cluster_kcsb)\n        self.ingest_client = QueuedIngestClient(self.ingest_kcsb)\n        self.database = database\n\n        self.timeout = 900\n\n        self.ingest_status = dict()\n        self.ingest_times = dict()\n\n    @staticmethod\n    def type_mapping(key: str, key_example_value) -&gt; str:\n\"\"\"\n        This method is used to replace the type name from python to the one used in ADX\n        :param key: the name of the key\n        :param key_example_value: a possible value of the key\n        :return: the name of the type used in ADX\n        \"\"\"\n\n        if key == \"SimulationRun\":\n            return \"guid\"\n\n        try:\n            # Use dateutil parser to test if the value could be a date, in case of error it is not\n            dateutil.parser.parse(key_example_value, fuzzy=False)\n            return \"datetime\"\n        except (ValueError, TypeError):\n            pass\n\n        if type(key_example_value) is float:\n            return \"real\"\n\n        if type(key_example_value) is int:\n            return \"long\"\n\n        # Default case to string\n        return \"string\"\n\n    def send_to_adx(self, dict_list: list, table_name: str, ignore_table_creation: bool = True,\n                    drop_by_tag: str = None):\n\"\"\"\n        Will take a list of dict items and send them to a given table in ADX\n        :param dict_list: list of dict objects requiring to have the same keys\n        :param table_name: The name of the table in which the data should be sent\n        :param ignore_table_creation: If set to True won't try to create a table to send the data\n        :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API\n        :return: A boolean check if the data have been sent to ADX\n        \"\"\"\n\n        if not ignore_table_creation:\n            # If the target table does not exist create it\n            # First create the columns types needed for the table\n            types = {k: self.type_mapping(k, dict_list[0][k]) for k in dict_list[0].keys()}\n            # Then try to create the table\n            if not self.create_table(table_name, types):\n                print(f\"Error creating table {table_name}.\")\n                return False\n\n        # Create a dataframe with the data to write and send them to ADX\n        df = pd.DataFrame(dict_list)\n        ingestion_result = self.ingest_dataframe(table_name, df, drop_by_tag)\n        return ingestion_result\n\n    def ingest_dataframe(self, table_name: str, dataframe: pd.DataFrame, drop_by_tag: str = None):\n\"\"\"\n        Write the content of dataframe to a table\n        :param table_name: name of the target table\n        :param dataframe: dataframe containing the data to be written\n        :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API\n        :return: None\n        \"\"\"\n        drop_by_tags = [drop_by_tag] if (drop_by_tag is not None) else None\n        properties = IngestionProperties(database=self.database, table=table_name, data_format=DataFormat.CSV,\n                                         drop_by_tags=drop_by_tags, report_level=ReportLevel.FailuresAndSuccesses)\n        client = self.ingest_client\n        ingestion_result = client.ingest_from_dataframe(dataframe, ingestion_properties=properties)\n        self.ingest_status[str(ingestion_result.source_id)] = IngestionStatus.QUEUED\n        self.ingest_times[str(ingestion_result.source_id)] = time.time()\n        return ingestion_result\n\n    def check_ingestion_status(self, source_ids: list[str],\n                               timeout: int = None,\n                               logs: bool = False) -&gt; Iterator[tuple[str, IngestionStatus]]:\n        remaining_ids = []\n        for source_id in source_ids:\n            if source_id not in self.ingest_status:\n                self.ingest_status[source_id] = IngestionStatus.UNKNOWN\n                self.ingest_times[source_id] = time.time()\n            if self.ingest_status[source_id] not in [IngestionStatus.QUEUED, IngestionStatus.UNKNOWN]:\n                yield source_id, self.ingest_status[source_id]\n            else:\n                remaining_ids.append(source_id)\n\n        qs = KustoIngestStatusQueues(self.ingest_client)\n\n        def get_messages(queues):\n            _r = []\n            for q in queues:\n                _r.extend(((q, m) for m in q.receive_messages(messages_per_page=32, visibility_timeout=1)))\n            return _r\n\n        successes = get_messages(qs.success._get_queues())\n        failures = get_messages(qs.failure._get_queues())\n\n        if logs:\n            print(f\"Success messages: {len(successes)}\")\n            print(f\"Failure messages: {len(failures)}\")\n        non_sent_ids = remaining_ids[:]\n        for messages, cast_func, status in [(successes, SuccessMessage, IngestionStatus.SUCCESS),\n                                            (failures, FailureMessage, IngestionStatus.FAILURE)]:\n            for _q, _m in messages:\n                dm = cast_func(_m.content)\n                to_check_ids = remaining_ids[:]\n                for source_id in to_check_ids:\n                    if dm.IngestionSourceId == str(source_id):\n                        self.ingest_status[source_id] = status\n                        if logs:\n                            print(f\"Found status for {source_id}: {status.value}\")\n                        _q.delete_message(_m)\n                        remaining_ids.remove(source_id)\n                        break\n                else:\n                    # The message did not correspond to a known ID\n                    continue\n                break\n            else:\n                # No message was found on the current list of messages for the given IDs\n                continue\n            break\n        else:\n            for source_id in remaining_ids:\n                if time.time() - self.ingest_times[source_id] &gt; ([timeout, self.timeout][timeout is None]):\n                    self.ingest_status[source_id] = IngestionStatus.TIMEOUT\n        for source_id in non_sent_ids:\n            yield source_id, self.ingest_status[source_id]\n\n    def _clear_ingestion_status_queues(self, confirmation: bool = False):\n\"\"\"\n        Dangerous operation that will fully clear all data in the ingestion status queues\n        Those queues are common to all databases in the ADX Cluster so don't ut this unless you know what you are doing\n        :param confirmation: Unless confirmation is set to True, won't do anything\n        :return:\n        \"\"\"\n        if confirmation:\n            qs = KustoIngestStatusQueues(self.ingest_client)\n            while not qs.success.is_empty():\n                qs.success.pop(32)\n            while not qs.failure.is_empty():\n                qs.failure.pop(32)\n\n    def run_command_query(self, query: str):\n\"\"\"\n        Execute a command query on the database\n        :param query: the query to execute\n        :return: the results of the query\n        \"\"\"\n        client = self.kusto_client\n        return client.execute_mgmt(self.database, query)\n\n    def run_query(self, query: str):\n\"\"\"\n        Execute a simple query on the database\n        :param query: the query to execute\n        :return: the results of the query\n        \"\"\"\n        client = self.kusto_client\n        return client.execute(self.database, query)\n\n    def table_exists(self, table_name: str) -&gt; bool:\n\"\"\"\n        Check if a table exists on the database\n        :param table_name: The table to look for\n        :return: does the table exits ?\n        \"\"\"\n        get_tables_query = f\".show database ['{self.database}'] schema| distinct TableName\"\n        tables = self.run_query(get_tables_query)\n        for r in tables.primary_results[0]:\n            if table_name == r[0]:\n                return True\n        return False\n\n    def create_table(self, table_name: str, schema: dict) -&gt; bool:\n\"\"\"\n        Create a table on the database\n        :param table_name: the name of the table\n        :param schema: the schema associated to the table\n        :return: Is the table created ?\n        \"\"\"\n        create_query = f\".create-merge table {table_name}(\"\n        for column_name, column_type in schema.items():\n            create_query += f\"{column_name}:{column_type},\"\n        create_query = create_query[:-1] + \")\"\n        try:\n            self.run_query(create_query)\n        except Exception as e:\n            print(e)\n            return False\n        return True\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.create_table","title":"<code>create_table(table_name, schema)</code>","text":"<p>Create a table on the database :param table_name: the name of the table :param schema: the schema associated to the table :return: Is the table created ?</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def create_table(self, table_name: str, schema: dict) -&gt; bool:\n\"\"\"\n    Create a table on the database\n    :param table_name: the name of the table\n    :param schema: the schema associated to the table\n    :return: Is the table created ?\n    \"\"\"\n    create_query = f\".create-merge table {table_name}(\"\n    for column_name, column_type in schema.items():\n        create_query += f\"{column_name}:{column_type},\"\n    create_query = create_query[:-1] + \")\"\n    try:\n        self.run_query(create_query)\n    except Exception as e:\n        print(e)\n        return False\n    return True\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.ingest_dataframe","title":"<code>ingest_dataframe(table_name, dataframe, drop_by_tag=None)</code>","text":"<p>Write the content of dataframe to a table :param table_name: name of the target table :param dataframe: dataframe containing the data to be written :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API :return: None</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def ingest_dataframe(self, table_name: str, dataframe: pd.DataFrame, drop_by_tag: str = None):\n\"\"\"\n    Write the content of dataframe to a table\n    :param table_name: name of the target table\n    :param dataframe: dataframe containing the data to be written\n    :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API\n    :return: None\n    \"\"\"\n    drop_by_tags = [drop_by_tag] if (drop_by_tag is not None) else None\n    properties = IngestionProperties(database=self.database, table=table_name, data_format=DataFormat.CSV,\n                                     drop_by_tags=drop_by_tags, report_level=ReportLevel.FailuresAndSuccesses)\n    client = self.ingest_client\n    ingestion_result = client.ingest_from_dataframe(dataframe, ingestion_properties=properties)\n    self.ingest_status[str(ingestion_result.source_id)] = IngestionStatus.QUEUED\n    self.ingest_times[str(ingestion_result.source_id)] = time.time()\n    return ingestion_result\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.run_command_query","title":"<code>run_command_query(query)</code>","text":"<p>Execute a command query on the database :param query: the query to execute :return: the results of the query</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def run_command_query(self, query: str):\n\"\"\"\n    Execute a command query on the database\n    :param query: the query to execute\n    :return: the results of the query\n    \"\"\"\n    client = self.kusto_client\n    return client.execute_mgmt(self.database, query)\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.run_query","title":"<code>run_query(query)</code>","text":"<p>Execute a simple query on the database :param query: the query to execute :return: the results of the query</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def run_query(self, query: str):\n\"\"\"\n    Execute a simple query on the database\n    :param query: the query to execute\n    :return: the results of the query\n    \"\"\"\n    client = self.kusto_client\n    return client.execute(self.database, query)\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.send_to_adx","title":"<code>send_to_adx(dict_list, table_name, ignore_table_creation=True, drop_by_tag=None)</code>","text":"<p>Will take a list of dict items and send them to a given table in ADX :param dict_list: list of dict objects requiring to have the same keys :param table_name: The name of the table in which the data should be sent :param ignore_table_creation: If set to True won't try to create a table to send the data :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API :return: A boolean check if the data have been sent to ADX</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def send_to_adx(self, dict_list: list, table_name: str, ignore_table_creation: bool = True,\n                drop_by_tag: str = None):\n\"\"\"\n    Will take a list of dict items and send them to a given table in ADX\n    :param dict_list: list of dict objects requiring to have the same keys\n    :param table_name: The name of the table in which the data should be sent\n    :param ignore_table_creation: If set to True won't try to create a table to send the data\n    :param drop_by_tag: Tag used for the drop by capacity of the Cosmotech API\n    :return: A boolean check if the data have been sent to ADX\n    \"\"\"\n\n    if not ignore_table_creation:\n        # If the target table does not exist create it\n        # First create the columns types needed for the table\n        types = {k: self.type_mapping(k, dict_list[0][k]) for k in dict_list[0].keys()}\n        # Then try to create the table\n        if not self.create_table(table_name, types):\n            print(f\"Error creating table {table_name}.\")\n            return False\n\n    # Create a dataframe with the data to write and send them to ADX\n    df = pd.DataFrame(dict_list)\n    ingestion_result = self.ingest_dataframe(table_name, df, drop_by_tag)\n    return ingestion_result\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.table_exists","title":"<code>table_exists(table_name)</code>","text":"<p>Check if a table exists on the database :param table_name: The table to look for :return: does the table exits ?</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>def table_exists(self, table_name: str) -&gt; bool:\n\"\"\"\n    Check if a table exists on the database\n    :param table_name: The table to look for\n    :return: does the table exits ?\n    \"\"\"\n    get_tables_query = f\".show database ['{self.database}'] schema| distinct TableName\"\n    tables = self.run_query(get_tables_query)\n    for r in tables.primary_results[0]:\n        if table_name == r[0]:\n            return True\n    return False\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.ADXQueriesWrapper.type_mapping","title":"<code>type_mapping(key, key_example_value)</code>  <code>staticmethod</code>","text":"<p>This method is used to replace the type name from python to the one used in ADX :param key: the name of the key :param key_example_value: a possible value of the key :return: the name of the type used in ADX</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>@staticmethod\ndef type_mapping(key: str, key_example_value) -&gt; str:\n\"\"\"\n    This method is used to replace the type name from python to the one used in ADX\n    :param key: the name of the key\n    :param key_example_value: a possible value of the key\n    :return: the name of the type used in ADX\n    \"\"\"\n\n    if key == \"SimulationRun\":\n        return \"guid\"\n\n    try:\n        # Use dateutil parser to test if the value could be a date, in case of error it is not\n        dateutil.parser.parse(key_example_value, fuzzy=False)\n        return \"datetime\"\n    except (ValueError, TypeError):\n        pass\n\n    if type(key_example_value) is float:\n        return \"real\"\n\n    if type(key_example_value) is int:\n        return \"long\"\n\n    # Default case to string\n    return \"string\"\n</code></pre>"},{"location":"references/Accelerators/adx_wrapper/#CosmoTech_Acceleration_Library.Accelerators.adx_wrapper.IngestionStatus","title":"<code>IngestionStatus</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/adx_wrapper.py</code> <pre><code>class IngestionStatus(Enum):\n    QUEUED = 'QUEUED'\n    SUCCESS = 'SUCCESS'\n    FAILURE = 'FAILURE'\n    UNKNOWN = 'UNKNOWN'\n    TIMEOUT = 'TIMED OUT'\n</code></pre>"},{"location":"references/Accelerators/cosmo_api/","title":"CosmoTech_Acceleration_Library.Accelerators.cosmo_api","text":""},{"location":"references/Accelerators/cosmo_api/#CosmoTech_Acceleration_Library.Accelerators.cosmo_api","title":"<code>cosmo_api</code>","text":""},{"location":"references/Accelerators/cosmo_api/#CosmoTech_Acceleration_Library.Accelerators.cosmo_api.get_current_scenario_data","title":"<code>get_current_scenario_data()</code>","text":"<p>Uses environment vars to find the current scenario data from the cosmotech api :return: a dict containing the data of the scenario from the API or None in another context</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/cosmo_api.py</code> <pre><code>def get_current_scenario_data():\n\"\"\"\n    Uses environment vars to find the current scenario data from the cosmotech api\n    :return: a dict containing the data of the scenario from the API or None in another context\n    \"\"\"\n    organization_id = os.environ.get(\"CSM_ORGANIZATION_ID\")\n    workspace_id = os.environ.get(\"CSM_WORKSPACE_ID\")\n    scenario_id = os.environ.get(\"CSM_SCENARIO_ID\")\n\n    if not all([organization_id, workspace_id, scenario_id]):\n        return None\n\n    with cosmotech_api.ApiClient(__get_configuration()) as api_client:\n        api_instance = ScenarioApi(api_client)\n        scenario_data = api_instance.find_scenario_by_id(organization_id=organization_id,\n                                                         workspace_id=workspace_id,\n                                                         scenario_id=scenario_id)\n    return scenario_data\n</code></pre>"},{"location":"references/Accelerators/cosmo_api/#CosmoTech_Acceleration_Library.Accelerators.cosmo_api.send_dataframe_to_api","title":"<code>send_dataframe_to_api(dataframe, file_name)</code>","text":"<p>Send a dataframe to the API</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/cosmo_api.py</code> <pre><code>def send_dataframe_to_api(dataframe, file_name: str):\n\"\"\"Send a dataframe to the API\"\"\"\n    file_content = io.StringIO()\n    dataframe.to_csv(file_content, index=False)\n    file_content.seek(0)\n    file_content.name = file_name.split('/')[-1]\n    send_file_to_api(file_content, file_name)\n</code></pre>"},{"location":"references/Accelerators/cosmo_api/#CosmoTech_Acceleration_Library.Accelerators.cosmo_api.send_file_to_api","title":"<code>send_file_to_api(file_content, file_name)</code>","text":"<p>Send a file to the api</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/cosmo_api.py</code> <pre><code>def send_file_to_api(file_content, file_name: str):\n\"\"\"Send a file to the api\"\"\"\n    organization_id = os.environ.get(\"CSM_ORGANIZATION_ID\")\n    workspace_id = os.environ.get(\"CSM_WORKSPACE_ID\")\n\n    with cosmotech_api.ApiClient(__get_configuration()) as api_client:\n        api_ws = WorkspaceApi(api_client)\n        api_ws.upload_workspace_file(organization_id=organization_id,\n                                     workspace_id=workspace_id,\n                                     file=file_content,\n                                     overwrite=True,\n                                     destination=file_name)\n</code></pre>"},{"location":"references/Accelerators/csm_engine/","title":"CosmoTech_Acceleration_Library.Accelerators.csm_engine","text":""},{"location":"references/Accelerators/csm_engine/#CosmoTech_Acceleration_Library.Accelerators.csm_engine","title":"<code>csm_engine</code>","text":""},{"location":"references/Accelerators/csm_engine/#CosmoTech_Acceleration_Library.Accelerators.csm_engine.apply_simple_csv_parameter_to_simulator","title":"<code>apply_simple_csv_parameter_to_simulator(simulator, parameter_name, target_attribute_name, csv_id_column='id', csv_value_column='value')</code>","text":"<p>Accelerator used to apply CSV parameters directly to a simulator Will raise a ValueError if the parameter does not exist If an entity is not found, will skip the row in the CSV :param simulator: The simulator object to which the parameter will be applied :param parameter_name: The name of the parameter fetched from the API :param target_attribute_name: Target attribute of the entities listed in the CSV :param csv_id_column: Column in the CSV file used for the entity ID :param csv_value_column: Column in the CSV file used for the attribute value to change :return: None</p> Source code in <code>CosmoTech_Acceleration_Library/Accelerators/csm_engine.py</code> <pre><code>def apply_simple_csv_parameter_to_simulator(simulator,\n                                            parameter_name: str,\n                                            target_attribute_name: str,\n                                            csv_id_column: str = \"id\",\n                                            csv_value_column: str = \"value\"):\n\"\"\"\n    Accelerator used to apply CSV parameters directly to a simulator\n    Will raise a ValueError if the parameter does not exist\n    If an entity is not found, will skip the row in the CSV\n    :param simulator: The simulator object to which the parameter will be applied\n    :param parameter_name: The name of the parameter fetched from the API\n    :param target_attribute_name: Target attribute of the entities listed in the CSV\n    :param csv_id_column: Column in the CSV file used for the entity ID\n    :param csv_value_column: Column in the CSV file used for the attribute value to change\n    :return: None\n    \"\"\"\n    parameter_path = os.path.join(parametersPath, parameter_name)\n    if os.path.exists(parameter_path):\n        csv_files = glob.glob(os.path.join(parameter_path, \"*.csv\"))\n        for csv_filename in csv_files:\n            model = simulator.GetModel()\n            with open(csv_filename, \"r\") as csv_file:\n                for row in csv.DictReader(csv_file):\n                    entity_name = row.get(csv_id_column)\n                    value = json.loads(row.get(csv_value_column))\n                    entity = model.FindEntityByName(entity_name)\n                    if entity:\n                        entity.SetAttributeAsString(target_attribute_name, json.dumps(value))\n    else:\n        raise ValueError(f\"Parameter {parameter_name} does not exists.\")\n</code></pre>"},{"location":"references/Accelerators/scenario_download/azure_function_main/","title":"CosmoTech_Acceleration_Library.Accelerators.scenario_download.azure_function_main","text":""},{"location":"references/Accelerators/scenario_download/azure_function_main/#CosmoTech_Acceleration_Library.Accelerators.scenario_download.azure_function_main","title":"<code>azure_function_main</code>","text":""},{"location":"references/Accelerators/scenario_download/scenario_downloader/","title":"CosmoTech_Acceleration_Library.Accelerators.scenario_download.scenario_downloader","text":""},{"location":"references/Accelerators/scenario_download/scenario_downloader/#CosmoTech_Acceleration_Library.Accelerators.scenario_download.scenario_downloader.ScenarioDownloader","title":"<code>ScenarioDownloader</code>","text":"Source code in <code>CosmoTech_Acceleration_Library/Accelerators/scenario_download/scenario_downloader.py</code> <pre><code>class ScenarioDownloader:\n\n    def __init__(self, workspace_id: str, organization_id: str):\n        self.credentials = DefaultAzureCredential()\n        scope = env.api_scope\n        token = self.credentials.get_token(scope)\n\n        self.configuration = cosmotech_api.Configuration(\n            host=env.api_host,\n            discard_unknown_keys=True,\n            access_token=token.token\n        )\n\n        self.workspace_id = workspace_id\n        self.organization_id = organization_id\n\n    def get_scenario_data(self, scenario_id: str):\n        with cosmotech_api.ApiClient(self.configuration) as api_client:\n            api_instance = ScenarioApi(api_client)\n            scenario_data = api_instance.find_scenario_by_id(organization_id=self.organization_id,\n                                                             workspace_id=self.workspace_id,\n                                                             scenario_id=scenario_id)\n        return scenario_data\n\n    def download_dataset(self, dataset_id: str) -&gt; (str, str, Union[str, None]):\n        with cosmotech_api.ApiClient(self.configuration) as api_client:\n            api_instance = DatasetApi(api_client)\n\n            dataset = api_instance.find_dataset_by_id(\n                organization_id=self.organization_id,\n                dataset_id=dataset_id)\n            parameters = dataset['connector']['parameters_values']\n\n            is_adt = 'AZURE_DIGITAL_TWINS_URL' in parameters\n            is_twin_cache = 'TWIN_CACHE_NAME' in parameters\n\n            if is_adt:\n                return {\n                    \"type\": 'adt',\n                    \"content\": self._download_adt_content(\n                        adt_adress=parameters['AZURE_DIGITAL_TWINS_URL']),\n                    \"name\": dataset['name']}\n            elif is_twin_cache:\n                twin_cache_name = parameters['TWIN_CACHE_NAME']\n                return {\n                    \"type\": \"adt\",\n                    \"content\": self._read_twingraph_content(twin_cache_name),\n                    \"name\": dataset[\"name\"]\n                }\n            else:\n                _file_name = parameters['AZURE_STORAGE_CONTAINER_BLOB_PREFIX'].replace(\n                    '%WORKSPACE_FILE%/', '')\n                return {\n                    \"type\": _file_name.split('.')[-1],\n                    \"content\": self._download_file(_file_name),\n                    \"name\": dataset['name']\n                }\n\n    def _read_twingraph_content(self, cache_name: str) -&gt; dict:\n        with cosmotech_api.ApiClient(self.configuration) as api_client:\n            api_instance = TwingraphApi(api_client)\n            _query_nodes = TwinGraphQuery(\n                query=\"MATCH(n) RETURN n\"\n            )\n            nodes = api_instance.query(\n                organization_id=self.organization_id,\n                graph_id=cache_name,\n                twin_graph_query=_query_nodes\n            )\n            _query_rel = TwinGraphQuery(\n                query=\"MATCH(n)-[r]-&gt;(m) RETURN n as src, r as rel, m as dest\"\n            )\n            rel = api_instance.query(\n                organization_id=self.organization_id,\n                graph_id=cache_name,\n                twin_graph_query=_query_rel\n            )\n\n            content = dict()\n            # build keys\n            for item in rel:\n                content[item['src']['label']] = list()\n                content[item['dest']['label']] = list()\n                content[item['rel']['label']] = list()\n\n            for item in nodes:\n                label = item['n']['label']\n                prop = item['n']['properties']\n                prop.update({'id': item['n']['id']})\n                content[label].append(prop)\n\n            for item in rel:\n                src = item['src']\n                dest = item['dest']\n                rel = item['rel']\n                props = item['rel']['properties']\n                content[rel['label']].append({\n                    'id': rel['id'],\n                    'source': src['id'],\n                    'target': dest['id'],\n                    **props\n                })\n\n            return content\n\n    def _download_file(self, file_name: str):\n        tmp_dataset_dir = tempfile.mkdtemp()\n        with cosmotech_api.ApiClient(self.configuration) as api_client:\n            api_ws = WorkspaceApi(api_client)\n\n            all_api_files = api_ws.find_all_workspace_files(\n                self.organization_id, self.workspace_id)\n\n            existing_files = list(\n                _f.to_dict().get('file_name') for _f in all_api_files\n                if _f.to_dict().get('file_name', '').startswith(file_name))\n\n            content = dict()\n\n            for _file_name in existing_files:\n                dl_file = api_ws.download_workspace_file(organization_id=self.organization_id,\n                                                         workspace_id=self.workspace_id,\n                                                         file_name=_file_name)\n\n                target_file = os.path.join(\n                    tmp_dataset_dir, _file_name.split('/')[-1])\n                with open(target_file, \"wb\") as tmp_file:\n                    tmp_file.write(dl_file.read())\n                if \".xls\" in _file_name:\n                    wb = load_workbook(target_file, data_only=True)\n                    for sheet_name in wb.sheetnames:\n                        sheet = wb[sheet_name]\n                        content[sheet_name] = list()\n                        headers = next(sheet.iter_rows(\n                            max_row=1, values_only=True))\n\n                        def item(_row: tuple) -&gt; dict:\n                            return {k: v for k, v in zip(headers, _row)}\n\n                        for r in sheet.iter_rows(min_row=2, values_only=True):\n                            row = item(r)\n                            new_row = dict()\n                            for key, value in row.items():\n                                try:\n                                    converted_value = json.load(\n                                        io.StringIO(value))\n                                except (json.decoder.JSONDecodeError, TypeError):\n                                    converted_value = value\n                                if converted_value is not None:\n                                    new_row[key] = converted_value\n                            if new_row:\n                                content[sheet_name].append(new_row)\n                elif \".csv\" in _file_name:\n                    with open(target_file, \"r\") as file:\n                        # Read every file in the input folder\n                        current_filename = os.path.basename(target_file)[\n                            :-len(\".csv\")]\n                        content[current_filename] = list()\n                        for row in csv.DictReader(file):\n                            new_row = dict()\n                            for key, value in row.items():\n                                try:\n                                    # Try to convert any json row to dict object\n                                    converted_value = json.load(\n                                        io.StringIO(value))\n                                except json.decoder.JSONDecodeError:\n                                    converted_value = value\n                                if converted_value == '':\n                                    converted_value = None\n                                if converted_value is not None:\n                                    new_row[key] = converted_value\n                            content[current_filename].append(new_row)\n                elif \".json\" in _file_name:\n                    with open(target_file, \"r\") as _file:\n                        current_filename = os.path.basename(target_file)\n                        content[current_filename] = json.load(_file)\n                else:\n                    with open(target_file, \"r\") as _file:\n                        current_filename = os.path.basename(target_file)\n                        content[current_filename] = \"\\n\".join(\n                            line for line in _file)\n        return content\n\n    def _download_adt_content(self, adt_adress: str) -&gt; dict:\n        client = DigitalTwinsClient(adt_adress, self.credentials)\n        query_expression = 'SELECT * FROM digitaltwins'\n        query_result = client.query_twins(query_expression)\n        json_content = dict()\n        for twin in query_result:\n            entity_type = twin.get('$metadata').get(\n                '$model').split(':')[-1].split(';')[0]\n            t_content = {k: v for k, v in twin.items()}\n            t_content['id'] = t_content['$dtId']\n            for k in twin.keys():\n                if k[0] == '$':\n                    del t_content[k]\n            json_content.setdefault(entity_type, [])\n            json_content[entity_type].append(t_content)\n\n        relations_query = 'SELECT * FROM relationships'\n        query_result = client.query_twins(relations_query)\n        for relation in query_result:\n            tr = {\n                \"$relationshipId\": \"id\",\n                \"$sourceId\": \"source\",\n                \"$targetId\": \"target\"\n            }\n            r_content = {k: v for k, v in relation.items()}\n            for k, v in tr.items():\n                r_content[v] = r_content[k]\n            for k in relation.keys():\n                if k[0] == '$':\n                    del r_content[k]\n            json_content.setdefault(relation['$relationshipName'], [])\n            json_content[relation['$relationshipName']].append(r_content)\n\n        return json_content\n\n    def get_all_parameters(self, scenario_id) -&gt; dict:\n        scenario_data = self.get_scenario_data(scenario_id=scenario_id)\n        content = dict()\n        for parameter in scenario_data['parameters_values']:\n            content[parameter['parameter_id']] = parameter['value']\n        return content\n\n    def get_all_datasets(self, scenario_id: str) -&gt; dict:\n        scenario_data = self.get_scenario_data(scenario_id=scenario_id)\n\n        datasets = scenario_data['dataset_list']\n\n        content = dict()\n        for dataset_id in datasets:\n            content[dataset_id] = self.download_dataset(dataset_id)\n\n        for parameter in scenario_data['parameters_values']:\n            if parameter['var_type'] == '%DATASETID%':\n                dataset_id = parameter['value']\n                content[dataset_id] = self.download_dataset(dataset_id)\n\n        return content\n</code></pre>"},{"location":"references/Accelerators/utils/multi_environment/","title":"CosmoTech_Acceleration_Library.Accelerators.utils.multi_environment","text":""},{"location":"references/Accelerators/utils/multi_environment/#CosmoTech_Acceleration_Library.Accelerators.utils.multi_environment.MultiEnvironment","title":"<code>MultiEnvironment</code>","text":"Source code in <code>CosmoTech_Acceleration_Library/Accelerators/utils/multi_environment.py</code> <pre><code>class MultiEnvironment:\n\n    def __init__(self):\n        self.api_host = None\n        self.api_scope = None\n\n        for host_var in ['COSMOTECH_API_SCOPE', 'CSM_API_SCOPE']:\n            if host_var in os.environ:\n                self.api_scope = os.environ.get(host_var)\n                break\n\n        for host_var in ['COSMOTECH_API_HOST', 'COSMOTECH_API_URL', 'CSM_API_HOST', 'CSM_API_URL']:\n            if host_var in os.environ:\n                self.api_host = os.environ.get(host_var)\n                break\n</code></pre>"},{"location":"references/Modelops/core/common/graph_handler/","title":"CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler","text":""},{"location":"references/Modelops/core/common/graph_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler.ExportableGraphHandler","title":"<code>ExportableGraphHandler</code>","text":"<p>         Bases: <code>VersionedGraphHandler</code></p> <p>Class that handle Exportable Versioned Graph Redis information</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/graph_handler.py</code> <pre><code>class ExportableGraphHandler(VersionedGraphHandler):\n\"\"\"\n    Class that handle Exportable Versioned Graph Redis information\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, version: int, password: str = None, source_url: str = \"\", export_dir: str = \"/\"):\n        super().__init__(host=host, port=port, name=name, version=version, password=password, source_url=source_url)\n        logger.debug(\"ExportableGraphHandler init\")\n        if export_dir != \"\":\n            Path(export_dir).mkdir(parents=True, exist_ok=True)\n            self.export_dir = export_dir\n        else:\n            self.export_dir = self.default_export_dir\n</code></pre>"},{"location":"references/Modelops/core/common/graph_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler.GraphHandler","title":"<code>GraphHandler</code>","text":"<p>         Bases: <code>RedisHandler</code></p> <p>Class that handle Graph Redis information</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/graph_handler.py</code> <pre><code>class GraphHandler(RedisHandler):\n\"\"\"\n    Class that handle Graph Redis information\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, password: str = None, source_url: str = \"\", graph_rotation: int = 3):\n        super().__init__(host=host, port=port, name=name, password=password)\n        logger.debug(\"GraphHandler init\")\n        self.graph = self.r.graph(name)\n        self.name = name\n        self.m_metadata = ModelMetadata(host=host, port=port, name=name, password=password)\n        current_metadata = self.m_metadata.get_metadata()\n        if not current_metadata:\n            logger.debug(\"Create metadata key\")\n            self.m_metadata.set_metadata(last_graph_version=0, graph_source_url=source_url,\n                                         graph_rotation=graph_rotation)\n</code></pre>"},{"location":"references/Modelops/core/common/graph_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler.RotatedGraphHandler","title":"<code>RotatedGraphHandler</code>","text":"<p>         Bases: <code>VersionedGraphHandler</code></p> <p>Class that handle Rotated Graph Redis information</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/graph_handler.py</code> <pre><code>class RotatedGraphHandler(VersionedGraphHandler):\n\"\"\"\n    Class that handle Rotated Graph Redis information\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, password: str = None, version: int = None, source_url: str = \"\",\n                 graph_rotation: int = 3):\n        super().__init__(host=host, port=port, name=name, password=password, source_url=source_url, version=version,\n                         graph_rotation=graph_rotation)\n        logger.debug(\"RotatedGraphHandler init\")\n        self.graph_rotation = graph_rotation\n\n    def handle_graph_rotation(func):\n\"\"\"\n        Decorator to do stuff then handle graph rotation (delete the oldest graph if the amount of graph is greater than graph rotation)\n        \"\"\"\n\n        def handle(self, *args, **kwargs):\n            # upgrade graph used\n            matching_graph_keys = self.r.keys(ModelUtil.build_graph_key_pattern(self.name))\n            graph_versions = []\n            for graph_key in matching_graph_keys:\n                graph_versions.append(graph_key.split(\":\")[-1])\n\n            min_version = 0\n            max_version = 0\n            if len(graph_versions) &gt; 0:\n                min_version = min([int(x) for x in graph_versions if x.isnumeric()])\n                max_version = max([int(x) for x in graph_versions if x.isnumeric()])\n            logger.debug(f\"{self.name} minimal version is: {min_version}\")\n            logger.debug(f\"{self.name} maximal version is: {max_version}\")\n\n            if len(matching_graph_keys) &gt; self.graph_rotation:  # TODO remove all oldest. in case rotation graph reduce mutliple deletion needed\n                oldest_graph_version_to_delete = ModelUtil.build_graph_version_name(self.name, min_version)\n                self.r.delete(oldest_graph_version_to_delete)\n                logger.debug(f\"Graph {oldest_graph_version_to_delete} deleted\")\n\n            self.version = max_version + 1\n            self.version_name = ModelUtil.build_graph_version_name(self.name, max_version + 1)\n            self.graph = self.r.graph(self.version_name)\n            logger.debug(f'Using graph version {self.version_name}, name {self.graph.name}')\n\n            # do function on new graph\n            func(self, *args, **kwargs)\n\n            # upgrade metadata last version to +1 after function execution\n            self.m_metadata.set_last_graph_version(self.version)\n\n        return handle\n</code></pre>"},{"location":"references/Modelops/core/common/graph_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler.RotatedGraphHandler.handle_graph_rotation","title":"<code>handle_graph_rotation(func)</code>","text":"<p>Decorator to do stuff then handle graph rotation (delete the oldest graph if the amount of graph is greater than graph rotation)</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/graph_handler.py</code> <pre><code>def handle_graph_rotation(func):\n\"\"\"\n    Decorator to do stuff then handle graph rotation (delete the oldest graph if the amount of graph is greater than graph rotation)\n    \"\"\"\n\n    def handle(self, *args, **kwargs):\n        # upgrade graph used\n        matching_graph_keys = self.r.keys(ModelUtil.build_graph_key_pattern(self.name))\n        graph_versions = []\n        for graph_key in matching_graph_keys:\n            graph_versions.append(graph_key.split(\":\")[-1])\n\n        min_version = 0\n        max_version = 0\n        if len(graph_versions) &gt; 0:\n            min_version = min([int(x) for x in graph_versions if x.isnumeric()])\n            max_version = max([int(x) for x in graph_versions if x.isnumeric()])\n        logger.debug(f\"{self.name} minimal version is: {min_version}\")\n        logger.debug(f\"{self.name} maximal version is: {max_version}\")\n\n        if len(matching_graph_keys) &gt; self.graph_rotation:  # TODO remove all oldest. in case rotation graph reduce mutliple deletion needed\n            oldest_graph_version_to_delete = ModelUtil.build_graph_version_name(self.name, min_version)\n            self.r.delete(oldest_graph_version_to_delete)\n            logger.debug(f\"Graph {oldest_graph_version_to_delete} deleted\")\n\n        self.version = max_version + 1\n        self.version_name = ModelUtil.build_graph_version_name(self.name, max_version + 1)\n        self.graph = self.r.graph(self.version_name)\n        logger.debug(f'Using graph version {self.version_name}, name {self.graph.name}')\n\n        # do function on new graph\n        func(self, *args, **kwargs)\n\n        # upgrade metadata last version to +1 after function execution\n        self.m_metadata.set_last_graph_version(self.version)\n\n    return handle\n</code></pre>"},{"location":"references/Modelops/core/common/graph_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.graph_handler.VersionedGraphHandler","title":"<code>VersionedGraphHandler</code>","text":"<p>         Bases: <code>GraphHandler</code></p> <p>Class that handle Versioned Graph Redis information</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/graph_handler.py</code> <pre><code>class VersionedGraphHandler(GraphHandler):\n\"\"\"\n    Class that handle Versioned Graph Redis information\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, version: int = None, password: str = None, source_url: str = \"\",\n                 graph_rotation: int = 3):\n        super().__init__(host=host, port=port, name=name, password=password, source_url=source_url,\n                         graph_rotation=graph_rotation)\n        logger.debug(\"VersionedGraphHandler init\")\n        self.version = version\n        if version is None:\n            self.version = self.m_metadata.get_last_graph_version()\n        self.versioned_name = ModelUtil.build_graph_version_name(self.name, self.version)\n        self.graph = self.r.graph(self.versioned_name)\n</code></pre>"},{"location":"references/Modelops/core/common/redis_handler/","title":"CosmoTech_Acceleration_Library.Modelops.core.common.redis_handler","text":""},{"location":"references/Modelops/core/common/redis_handler/#CosmoTech_Acceleration_Library.Modelops.core.common.redis_handler.RedisHandler","title":"<code>RedisHandler</code>","text":"<p>Class that handle Redis informations</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/redis_handler.py</code> <pre><code>class RedisHandler:\n\"\"\"\n    Class that handle Redis informations\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, password: str = None):\n        logger.debug(\"RedisHandler init\")\n        self.host = host\n        self.port = port\n        self.name = name\n        self.password = password\n        self.r = redis.Redis(host=host, port=port, password=password, decode_responses=True)\n        self.metadata_key = name + \"MetaData\"\n</code></pre>"},{"location":"references/Modelops/core/common/writer/CsvWriter/","title":"CosmoTech_Acceleration_Library.Modelops.core.common.writer.CsvWriter","text":""},{"location":"references/Modelops/core/common/writer/CsvWriter/#CosmoTech_Acceleration_Library.Modelops.core.common.writer.CsvWriter.CsvWriter","title":"<code>CsvWriter</code>","text":"<p>Csv Writer class</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/common/writer/CsvWriter.py</code> <pre><code>class CsvWriter:\n\"\"\"\n    Csv Writer class\n    \"\"\"\n\n    @staticmethod\n    def _to_csv_format(val: any) -&gt; str:\n        if isinstance(val, bool):\n            return str(val).lower()\n        if str(val) == 'True' or str(val) == 'False':\n            return str(val).lower()\n        return str(val)\n\n    @staticmethod\n    def _to_cosmo_key(val: any) -&gt; str:\n        if str(val) == ModelUtil.dt_id_key:\n            return ModelUtil.id_key\n        return val\n\n    @staticmethod\n    def write_twin_data(export_dir: str, file_name: str, query_result: QueryResult,\n                        delimiter: str = ',', quote_char: str = '\\\"') -&gt; None:\n        headers = set()\n        rows = []\n        for raw_data in query_result.result_set:\n            row = {}\n            # read all graph link properties\n            for i in range(len(raw_data)):  # TODO for the moment its only a len 1 list with the node\n                row.update({CsvWriter._to_cosmo_key(k): CsvWriter._to_csv_format(v) for k, v in raw_data[i].properties.items()})\n            headers.update(row.keys())\n            rows.append(row)\n\n        output_file_name = f'{export_dir}/{file_name}.csv'\n        logger.debug(f\"Writing CSV file {output_file_name}\")\n        with open(output_file_name, 'w') as csvfile:\n            csv_writer = csv.DictWriter(csvfile, fieldnames=headers, delimiter=delimiter, quotechar=quote_char, quoting=csv.QUOTE_ALL)\n            csv_writer.writeheader()\n            csv_writer.writerows(rows)\n        logger.debug(f\"... CSV file {output_file_name} has been written\")\n\n    @staticmethod\n    def write_relationship_data(export_dir: str, file_name: str, query_result: QueryResult, headers: list = [],\n                                delimiter: str = ',', quote_char: str = '\\\"') -&gt; None:\n        headers = {'source', 'target'}\n        rows = []\n        for raw_data in query_result.result_set:\n            row = {'source': raw_data[0], 'target': raw_data[1]}\n            row.update({k: CsvWriter._to_csv_format(v) for k, v in raw_data[2].properties.items()})\n            headers.update(row.keys())\n            rows.append(row)\n\n        output_file_name = export_dir + file_name + '.csv'\n        logger.debug(f\"Writing CSV file {output_file_name}\")\n        with open(output_file_name, 'w') as csvfile:\n            csv_writer = csv.DictWriter(csvfile, fieldnames=headers, delimiter=delimiter, quotechar=quote_char, quoting=csv.QUOTE_ALL)\n            csv_writer.writeheader()\n            csv_writer.writerows(rows)\n        logger.debug(f\"... CSV file {output_file_name} has been written\")\n</code></pre>"},{"location":"references/Modelops/core/decorators/model_decorators/","title":"CosmoTech_Acceleration_Library.Modelops.core.decorators.model_decorators","text":""},{"location":"references/Modelops/core/decorators/model_decorators/#CosmoTech_Acceleration_Library.Modelops.core.decorators.model_decorators","title":"<code>model_decorators</code>","text":""},{"location":"references/Modelops/core/decorators/model_decorators/#CosmoTech_Acceleration_Library.Modelops.core.decorators.model_decorators.do_if_graph_exist","title":"<code>do_if_graph_exist(function)</code>","text":"<p>Function decorator that run the function annotated if versioned graph exists :param function: the function annotated</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/decorators/model_decorators.py</code> <pre><code>def do_if_graph_exist(function):\n\"\"\"\n    Function decorator that run the function annotated if versioned graph exists\n    :param function: the function annotated\n    \"\"\"\n\n    @functools.wraps(function)\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        version_graph_name = self.versioned_name\n        if isinstance(self, ExportableGraphHandler):\n            key_count = self.r.exists(version_graph_name)\n            if key_count != 0:\n                function(*args, **kwargs)\n            else:\n                raise Exception(f\"{version_graph_name} does not exist!\")\n        else:\n            function(*args, **kwargs)\n    return wrapper\n</code></pre>"},{"location":"references/Modelops/core/decorators/model_decorators/#CosmoTech_Acceleration_Library.Modelops.core.decorators.model_decorators.update_last_modified_date","title":"<code>update_last_modified_date(function)</code>","text":"<p>Function decorator that update metadata last modified date after calling the function annotated :param function: the function annotated</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/decorators/model_decorators.py</code> <pre><code>def update_last_modified_date(function):\n\"\"\"\n    Function decorator that update metadata last modified date after calling the function annotated\n    :param function: the function annotated\n    \"\"\"\n\n    @functools.wraps(function)\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        if isinstance(self, GraphHandler):\n            function(*args, **kwargs)\n            self.m_metadata.update_last_modified_date()\n        else:\n            function(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"references/Modelops/core/decorators/model_decorators/#CosmoTech_Acceleration_Library.Modelops.core.decorators.model_decorators.update_last_version","title":"<code>update_last_version(function)</code>","text":"<p>Function decorator that update metadata last version after calling the function annotated :param function: the function annotated</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/decorators/model_decorators.py</code> <pre><code>def update_last_version(function):\n\"\"\"\n    Function decorator that update metadata last version after calling the function annotated\n    :param function: the function annotated\n    \"\"\"\n\n    @functools.wraps(function)\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        if isinstance(self, GraphHandler):\n            function(*args, **kwargs)\n            self.m_metadata.update_last_version()\n        else:\n            function(*args, **kwargs)\n    return wrapper\n</code></pre>"},{"location":"references/Modelops/core/io/model_exporter/","title":"CosmoTech_Acceleration_Library.Modelops.core.io.model_exporter","text":""},{"location":"references/Modelops/core/io/model_exporter/#CosmoTech_Acceleration_Library.Modelops.core.io.model_exporter.ModelExporter","title":"<code>ModelExporter</code>","text":"<p>         Bases: <code>ExportableGraphHandler</code></p> <p>Model Exporter for cached data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_exporter.py</code> <pre><code>class ModelExporter(ExportableGraphHandler):\n\"\"\"\n    Model Exporter for cached data\n    \"\"\"\n\n    def __init__(self, host: str, port: int, name: str, version: int, password: str = None, export_dir: str = \"/\"):\n        super().__init__(host=host, port=port, name=name, version=version, password=password, export_dir=export_dir)\n        self.mr = ModelReader(host=host, port=port, name=name, password=password, version=version)\n\n    @do_if_graph_exist\n    def export_all_twins(self):\n\"\"\"\n        Export all twins\n        :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type\n        \"\"\"\n        logger.debug(\"Start exporting twins...\")\n        logger.debug(\"Get twin types...\")\n        get_types_start = time.time()\n        twin_names = self.mr.get_twin_types()\n        get_types_end = time.time() - get_types_start\n        logger.debug(f\"Get twin types took {get_types_end} s\")\n\n        for twin_name in twin_names:\n            logger.debug(f\"Get twin info for type {twin_name} ...\")\n\n            get_twin_info_start = time.time()\n            twin_results = self.mr.get_twins_by_type(twin_name)\n            get_twin_info_end = time.time() - get_twin_info_start\n\n            logger.debug(f\"Get twin info for type {twin_name} took {get_twin_info_end} s\")\n            logger.debug(f\"Export twin info for type {twin_name} ...\")\n\n            export_twin_info_start = time.time()\n            CsvWriter.write_twin_data(self.export_dir, twin_name, twin_results)\n            export_twin_info_end = time.time() - export_twin_info_start\n\n            logger.debug(f\"Export twin info for type {twin_name} took {export_twin_info_end} s\")\n            logger.debug(f\"Twins exported :{twin_name}\")\n        logger.debug(\"... End exporting twins\")\n\n    @do_if_graph_exist\n    def export_all_relationships(self):\n\"\"\"\n        Export all relationships\n        :return: Csv files containing all relationship instances exported into {export_dir}\n        folder named by relationship type\n        \"\"\"\n        logger.debug(\"Start exporting relationships...\")\n        logger.debug(\"Get relationship types...\")\n        get_relationship_types_start = time.time()\n        relationship_names = self.mr.get_relationship_types()\n        get_relationship_types_end = time.time() - get_relationship_types_start\n        logger.debug(f\"Get relationship types took {get_relationship_types_end} s\")\n\n        for relationship_name in relationship_names:\n            logger.debug(f\"Get relationship info for type {relationship_name} ...\")\n\n            get_relationship_info_start = time.time()\n            headers = self.mr.get_relationship_properties_by_type(relationship_name)\n            relationship_result = self.mr.get_relationships_by_type(relationship_name)\n\n            get_relationship_info_end = time.time() - get_relationship_info_start\n            logger.debug(f\"Get relationship info for type {relationship_name} took {get_relationship_info_end} s\")\n            logger.debug(f\"Export relationship info for type {relationship_name} ...\")\n\n            export_relationship_info_start = time.time()\n            CsvWriter.write_relationship_data(self.export_dir, relationship_name, relationship_result)\n            export_relationship_info_end = time.time() - export_relationship_info_start\n\n            logger.debug(f\"Export relationship info for type {relationship_name} took {export_relationship_info_end} s\")\n            logger.debug(f\"Relationships exported :{relationship_name}\")\n        logger.debug(\"... End exporting relationships\")\n\n    @do_if_graph_exist\n    def export_all_data(self):\n\"\"\"\n        Export all data\n        :return: a bunch of csv files corresponding to graph data\n        \"\"\"\n        self.export_all_twins()\n        self.export_all_relationships()\n</code></pre>"},{"location":"references/Modelops/core/io/model_exporter/#CosmoTech_Acceleration_Library.Modelops.core.io.model_exporter.ModelExporter.export_all_data","title":"<code>export_all_data()</code>","text":"<p>Export all data :return: a bunch of csv files corresponding to graph data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_exporter.py</code> <pre><code>@do_if_graph_exist\ndef export_all_data(self):\n\"\"\"\n    Export all data\n    :return: a bunch of csv files corresponding to graph data\n    \"\"\"\n    self.export_all_twins()\n    self.export_all_relationships()\n</code></pre>"},{"location":"references/Modelops/core/io/model_exporter/#CosmoTech_Acceleration_Library.Modelops.core.io.model_exporter.ModelExporter.export_all_relationships","title":"<code>export_all_relationships()</code>","text":"<p>Export all relationships :return: Csv files containing all relationship instances exported into {export_dir} folder named by relationship type</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_exporter.py</code> <pre><code>@do_if_graph_exist\ndef export_all_relationships(self):\n\"\"\"\n    Export all relationships\n    :return: Csv files containing all relationship instances exported into {export_dir}\n    folder named by relationship type\n    \"\"\"\n    logger.debug(\"Start exporting relationships...\")\n    logger.debug(\"Get relationship types...\")\n    get_relationship_types_start = time.time()\n    relationship_names = self.mr.get_relationship_types()\n    get_relationship_types_end = time.time() - get_relationship_types_start\n    logger.debug(f\"Get relationship types took {get_relationship_types_end} s\")\n\n    for relationship_name in relationship_names:\n        logger.debug(f\"Get relationship info for type {relationship_name} ...\")\n\n        get_relationship_info_start = time.time()\n        headers = self.mr.get_relationship_properties_by_type(relationship_name)\n        relationship_result = self.mr.get_relationships_by_type(relationship_name)\n\n        get_relationship_info_end = time.time() - get_relationship_info_start\n        logger.debug(f\"Get relationship info for type {relationship_name} took {get_relationship_info_end} s\")\n        logger.debug(f\"Export relationship info for type {relationship_name} ...\")\n\n        export_relationship_info_start = time.time()\n        CsvWriter.write_relationship_data(self.export_dir, relationship_name, relationship_result)\n        export_relationship_info_end = time.time() - export_relationship_info_start\n\n        logger.debug(f\"Export relationship info for type {relationship_name} took {export_relationship_info_end} s\")\n        logger.debug(f\"Relationships exported :{relationship_name}\")\n    logger.debug(\"... End exporting relationships\")\n</code></pre>"},{"location":"references/Modelops/core/io/model_exporter/#CosmoTech_Acceleration_Library.Modelops.core.io.model_exporter.ModelExporter.export_all_twins","title":"<code>export_all_twins()</code>","text":"<p>Export all twins :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_exporter.py</code> <pre><code>@do_if_graph_exist\ndef export_all_twins(self):\n\"\"\"\n    Export all twins\n    :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type\n    \"\"\"\n    logger.debug(\"Start exporting twins...\")\n    logger.debug(\"Get twin types...\")\n    get_types_start = time.time()\n    twin_names = self.mr.get_twin_types()\n    get_types_end = time.time() - get_types_start\n    logger.debug(f\"Get twin types took {get_types_end} s\")\n\n    for twin_name in twin_names:\n        logger.debug(f\"Get twin info for type {twin_name} ...\")\n\n        get_twin_info_start = time.time()\n        twin_results = self.mr.get_twins_by_type(twin_name)\n        get_twin_info_end = time.time() - get_twin_info_start\n\n        logger.debug(f\"Get twin info for type {twin_name} took {get_twin_info_end} s\")\n        logger.debug(f\"Export twin info for type {twin_name} ...\")\n\n        export_twin_info_start = time.time()\n        CsvWriter.write_twin_data(self.export_dir, twin_name, twin_results)\n        export_twin_info_end = time.time() - export_twin_info_start\n\n        logger.debug(f\"Export twin info for type {twin_name} took {export_twin_info_end} s\")\n        logger.debug(f\"Twins exported :{twin_name}\")\n    logger.debug(\"... End exporting twins\")\n</code></pre>"},{"location":"references/Modelops/core/io/model_importer/","title":"CosmoTech_Acceleration_Library.Modelops.core.io.model_importer","text":""},{"location":"references/Modelops/core/io/model_importer/#CosmoTech_Acceleration_Library.Modelops.core.io.model_importer.ModelImporter","title":"<code>ModelImporter</code>","text":"<p>         Bases: <code>RotatedGraphHandler</code></p> <p>Model Exporter for cached data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_importer.py</code> <pre><code>class ModelImporter(RotatedGraphHandler):\n\"\"\"\n    Model Exporter for cached data\n    \"\"\"\n\n    @RotatedGraphHandler.handle_graph_rotation\n    def bulk_import(self, twin_file_paths: list = [], relationship_file_paths: list = [], enforce_schema: bool = False):\n\"\"\"\n        Import all csv data\n        :param twin_file_paths: the file paths of all twin csv files\n        :param relationship_file_paths: the file paths of all relationship csv files\n        :param enforce_schema: True if the schema is defined within headers (default False)\n        `Enforce_schema documentation &lt;https://github.com/RedisGraph/redisgraph-bulk-loader#input-schemas&gt;`_\n        :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type\n        \"\"\"\n        command_parameters = ['--host', self.host, '--port', self.port]\n\n        if self.password is not None:\n            command_parameters.append('--password')\n            command_parameters.append(self.password)\n\n        if enforce_schema:\n            command_parameters.append('--enforce-schema')\n\n        for twin_file_path in twin_file_paths:\n            if twin_file_path != \"\":\n                command_parameters.append('--nodes')\n                command_parameters.append(twin_file_path)\n\n        for relationship_file_path in relationship_file_paths:\n            if relationship_file_path != \"\":\n                command_parameters.append('--relations')\n                command_parameters.append(relationship_file_path)\n\n        command_parameters.append(ModelUtil.build_graph_version_name(self.name, self.version))\n        logger.debug(command_parameters)\n        # TODO: Think about use '--index Label:Property' command parameters to create indexes on default id properties\n        try:\n            bulk_insert(command_parameters)\n        except SystemExit as e:\n            print(e)\n</code></pre>"},{"location":"references/Modelops/core/io/model_importer/#CosmoTech_Acceleration_Library.Modelops.core.io.model_importer.ModelImporter.bulk_import","title":"<code>bulk_import(twin_file_paths=[], relationship_file_paths=[], enforce_schema=False)</code>","text":"<p>Import all csv data :param twin_file_paths: the file paths of all twin csv files :param relationship_file_paths: the file paths of all relationship csv files :param enforce_schema: True if the schema is defined within headers (default False) <code>Enforce_schema documentation &lt;https://github.com/RedisGraph/redisgraph-bulk-loader#input-schemas&gt;</code>_ :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_importer.py</code> <pre><code>@RotatedGraphHandler.handle_graph_rotation\ndef bulk_import(self, twin_file_paths: list = [], relationship_file_paths: list = [], enforce_schema: bool = False):\n\"\"\"\n    Import all csv data\n    :param twin_file_paths: the file paths of all twin csv files\n    :param relationship_file_paths: the file paths of all relationship csv files\n    :param enforce_schema: True if the schema is defined within headers (default False)\n    `Enforce_schema documentation &lt;https://github.com/RedisGraph/redisgraph-bulk-loader#input-schemas&gt;`_\n    :return: Csv files containing all twin instances exported into {export_dir} folder named by twin type\n    \"\"\"\n    command_parameters = ['--host', self.host, '--port', self.port]\n\n    if self.password is not None:\n        command_parameters.append('--password')\n        command_parameters.append(self.password)\n\n    if enforce_schema:\n        command_parameters.append('--enforce-schema')\n\n    for twin_file_path in twin_file_paths:\n        if twin_file_path != \"\":\n            command_parameters.append('--nodes')\n            command_parameters.append(twin_file_path)\n\n    for relationship_file_path in relationship_file_paths:\n        if relationship_file_path != \"\":\n            command_parameters.append('--relations')\n            command_parameters.append(relationship_file_path)\n\n    command_parameters.append(ModelUtil.build_graph_version_name(self.name, self.version))\n    logger.debug(command_parameters)\n    # TODO: Think about use '--index Label:Property' command parameters to create indexes on default id properties\n    try:\n        bulk_insert(command_parameters)\n    except SystemExit as e:\n        print(e)\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/","title":"CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata","text":""},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata","title":"<code>ModelMetadata</code>","text":"<p>         Bases: <code>RedisHandler</code></p> <p>Model Metadata management class for cached data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>class ModelMetadata(RedisHandler):\n\"\"\"\n    Model Metadata management class for cached data\n    \"\"\"\n\n    last_modified_date_key = \"lastModifiedDate\"\n    last_version_key = \"lastVersion\"\n    source_url_key = \"adtUrl\"\n    graph_name_key = \"graphName\"\n    graph_rotation_key = \"graphRotation\"\n\n    def get_metadata(self) -&gt; dict:\n\"\"\"\n        Get the metadata of the graph\n        :return: the dict containing all graph metadata\n        \"\"\"\n        return self.r.hgetall(self.metadata_key)\n\n    def get_last_graph_version(self) -&gt; str:\n\"\"\"\n        Get the current last version of the graph\n        :return: the graph last version\n        \"\"\"\n        return self.get_metadata()[self.last_version_key]\n\n    def get_graph_name(self) -&gt; str:\n\"\"\"\n        Get the graph's name\n        :return: the graph's name\n        \"\"\"\n        return self.name\n\n    def get_graph_source_url(self) -&gt; str:\n\"\"\"\n        Get the datasource of the graph\n        :return: the datasource of the graph\n        \"\"\"\n        return self.get_metadata()[self.source_url_key]\n\n    def get_graph_rotation(self) -&gt; str:\n\"\"\"\n        Get the graph rotation of the graph\n        :return: the graph rotation of the graph\n        \"\"\"\n        return self.get_metadata()[self.graph_rotation_key]\n\n    def get_last_modified_date(self) -&gt; datetime:\n\"\"\"\n        Get the last modified date of the graph\n        :return: the last modified date of the graph\n        \"\"\"\n        metadata_last_version = self.get_metadata()[self.last_modified_date_key]\n        return ModelUtil.convert_str_to_datetime(metadata_last_version)\n\n    def set_all_metadata(self, metadata: dict):\n\"\"\"\n        Set the metadata of the graph\n        :param metadata the metadata to set\n        :raise Exception if the current version is greater than the new one\n        \"\"\"\n        current_metadata = self.get_metadata()\n        if self.last_version_key in current_metadata:\n            current_version = int(self.get_last_graph_version())\n            new_version = int(metadata[self.last_version_key])\n            if new_version &gt; current_version:\n                logger.debug(f\"Metatadata to set : {metadata}\")\n                self.r.hmset(self.metadata_key, metadata)\n            else:\n                raise Exception(f\"The current version {current_version} is equal or greater than the version to set: {new_version}\")\n        else:\n            logger.debug(f\"Metatadata to set : {metadata}\")\n            self.r.hmset(self.metadata_key, metadata)\n\n    def set_metadata(self,\n                     last_graph_version: int,\n                     graph_source_url: str,\n                     graph_rotation: int) -&gt; dict:\n\"\"\"\n        Set the metadata of the graph\n        :param last_graph_version the new version\n        :param graph_source_url the source url\n        :param graph_rotation the graph rotation\n        :return the metadata set\n        :raise Exception if the current version is greater than the new one\n        \"\"\"\n        metadata = {\n            self.last_version_key: str(last_graph_version),\n            self.graph_name_key: self.name,\n            self.source_url_key: graph_source_url,\n            self.graph_rotation_key: str(graph_rotation),\n            self.last_modified_date_key: ModelUtil.convert_datetime_to_str(datetime.utcnow())\n        }\n        logger.debug(f\"Metatadata to set : {metadata}\")\n        self.set_all_metadata(metadata=metadata)\n\n    def set_last_graph_version(self, last_graph_version: int):\n\"\"\"\n        Set the current last version of the graph\n        :param last_graph_version the new version\n        \"\"\"\n        self.r.hset(self.metadata_key, self.last_version_key, str(last_graph_version))\n        logger.debug(f\"Graph last_graph_version to set : {str(last_graph_version)}\")\n        self.update_last_modified_date()\n\n    def set_graph_source_url(self, graph_source_url: str):\n\"\"\"\n        Set the datasource of the graph\n        :param graph_source_url the source url\n        \"\"\"\n        self.r.hset(self.metadata_key, self.source_url_key, graph_source_url)\n        logger.debug(f\"Graph source_url to set : {str(graph_source_url)}\")\n        self.update_last_modified_date()\n\n    def set_graph_rotation(self, graph_rotation: int):\n\"\"\"\n        Set the graph rotation of the graph\n        :param graph_rotation the graph rotation\n        \"\"\"\n        self.r.hset(self.metadata_key, self.graph_rotation_key, str(graph_rotation))\n        logger.debug(f\"Graph graph_rotation to set : {str(graph_rotation)}\")\n        self.update_last_modified_date()\n\n    def update_last_modified_date(self):\n\"\"\"\n        Update the last modified date of the graph\n        \"\"\"\n        self.r.hset(self.metadata_key, self.last_modified_date_key, ModelUtil.convert_datetime_to_str(datetime.utcnow()))\n\n    def update_last_version(self):\n\"\"\"\n        Update the last version of the graph\n        \"\"\"\n        current_metadata = self.get_metadata()\n        if self.last_version_key in current_metadata:\n            current_version = int(self.get_last_graph_version())\n            new_version = current_version + 1\n            self.set_last_graph_version(str(new_version))\n            self.update_last_modified_date()\n        else:\n            self.set_last_graph_version(\"0\")\n            self.update_last_modified_date()\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_graph_name","title":"<code>get_graph_name()</code>","text":"<p>Get the graph's name :return: the graph's name</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_graph_name(self) -&gt; str:\n\"\"\"\n    Get the graph's name\n    :return: the graph's name\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_graph_rotation","title":"<code>get_graph_rotation()</code>","text":"<p>Get the graph rotation of the graph :return: the graph rotation of the graph</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_graph_rotation(self) -&gt; str:\n\"\"\"\n    Get the graph rotation of the graph\n    :return: the graph rotation of the graph\n    \"\"\"\n    return self.get_metadata()[self.graph_rotation_key]\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_graph_source_url","title":"<code>get_graph_source_url()</code>","text":"<p>Get the datasource of the graph :return: the datasource of the graph</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_graph_source_url(self) -&gt; str:\n\"\"\"\n    Get the datasource of the graph\n    :return: the datasource of the graph\n    \"\"\"\n    return self.get_metadata()[self.source_url_key]\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_last_graph_version","title":"<code>get_last_graph_version()</code>","text":"<p>Get the current last version of the graph :return: the graph last version</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_last_graph_version(self) -&gt; str:\n\"\"\"\n    Get the current last version of the graph\n    :return: the graph last version\n    \"\"\"\n    return self.get_metadata()[self.last_version_key]\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_last_modified_date","title":"<code>get_last_modified_date()</code>","text":"<p>Get the last modified date of the graph :return: the last modified date of the graph</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_last_modified_date(self) -&gt; datetime:\n\"\"\"\n    Get the last modified date of the graph\n    :return: the last modified date of the graph\n    \"\"\"\n    metadata_last_version = self.get_metadata()[self.last_modified_date_key]\n    return ModelUtil.convert_str_to_datetime(metadata_last_version)\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Get the metadata of the graph :return: the dict containing all graph metadata</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n\"\"\"\n    Get the metadata of the graph\n    :return: the dict containing all graph metadata\n    \"\"\"\n    return self.r.hgetall(self.metadata_key)\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.set_all_metadata","title":"<code>set_all_metadata(metadata)</code>","text":"<p>Set the metadata of the graph :param metadata the metadata to set :raise Exception if the current version is greater than the new one</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def set_all_metadata(self, metadata: dict):\n\"\"\"\n    Set the metadata of the graph\n    :param metadata the metadata to set\n    :raise Exception if the current version is greater than the new one\n    \"\"\"\n    current_metadata = self.get_metadata()\n    if self.last_version_key in current_metadata:\n        current_version = int(self.get_last_graph_version())\n        new_version = int(metadata[self.last_version_key])\n        if new_version &gt; current_version:\n            logger.debug(f\"Metatadata to set : {metadata}\")\n            self.r.hmset(self.metadata_key, metadata)\n        else:\n            raise Exception(f\"The current version {current_version} is equal or greater than the version to set: {new_version}\")\n    else:\n        logger.debug(f\"Metatadata to set : {metadata}\")\n        self.r.hmset(self.metadata_key, metadata)\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.set_graph_rotation","title":"<code>set_graph_rotation(graph_rotation)</code>","text":"<p>Set the graph rotation of the graph :param graph_rotation the graph rotation</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def set_graph_rotation(self, graph_rotation: int):\n\"\"\"\n    Set the graph rotation of the graph\n    :param graph_rotation the graph rotation\n    \"\"\"\n    self.r.hset(self.metadata_key, self.graph_rotation_key, str(graph_rotation))\n    logger.debug(f\"Graph graph_rotation to set : {str(graph_rotation)}\")\n    self.update_last_modified_date()\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.set_graph_source_url","title":"<code>set_graph_source_url(graph_source_url)</code>","text":"<p>Set the datasource of the graph :param graph_source_url the source url</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def set_graph_source_url(self, graph_source_url: str):\n\"\"\"\n    Set the datasource of the graph\n    :param graph_source_url the source url\n    \"\"\"\n    self.r.hset(self.metadata_key, self.source_url_key, graph_source_url)\n    logger.debug(f\"Graph source_url to set : {str(graph_source_url)}\")\n    self.update_last_modified_date()\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.set_last_graph_version","title":"<code>set_last_graph_version(last_graph_version)</code>","text":"<p>Set the current last version of the graph :param last_graph_version the new version</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def set_last_graph_version(self, last_graph_version: int):\n\"\"\"\n    Set the current last version of the graph\n    :param last_graph_version the new version\n    \"\"\"\n    self.r.hset(self.metadata_key, self.last_version_key, str(last_graph_version))\n    logger.debug(f\"Graph last_graph_version to set : {str(last_graph_version)}\")\n    self.update_last_modified_date()\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.set_metadata","title":"<code>set_metadata(last_graph_version, graph_source_url, graph_rotation)</code>","text":"<p>Set the metadata of the graph :param last_graph_version the new version :param graph_source_url the source url :param graph_rotation the graph rotation :return the metadata set :raise Exception if the current version is greater than the new one</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def set_metadata(self,\n                 last_graph_version: int,\n                 graph_source_url: str,\n                 graph_rotation: int) -&gt; dict:\n\"\"\"\n    Set the metadata of the graph\n    :param last_graph_version the new version\n    :param graph_source_url the source url\n    :param graph_rotation the graph rotation\n    :return the metadata set\n    :raise Exception if the current version is greater than the new one\n    \"\"\"\n    metadata = {\n        self.last_version_key: str(last_graph_version),\n        self.graph_name_key: self.name,\n        self.source_url_key: graph_source_url,\n        self.graph_rotation_key: str(graph_rotation),\n        self.last_modified_date_key: ModelUtil.convert_datetime_to_str(datetime.utcnow())\n    }\n    logger.debug(f\"Metatadata to set : {metadata}\")\n    self.set_all_metadata(metadata=metadata)\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.update_last_modified_date","title":"<code>update_last_modified_date()</code>","text":"<p>Update the last modified date of the graph</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def update_last_modified_date(self):\n\"\"\"\n    Update the last modified date of the graph\n    \"\"\"\n    self.r.hset(self.metadata_key, self.last_modified_date_key, ModelUtil.convert_datetime_to_str(datetime.utcnow()))\n</code></pre>"},{"location":"references/Modelops/core/io/model_metadata/#CosmoTech_Acceleration_Library.Modelops.core.io.model_metadata.ModelMetadata.update_last_version","title":"<code>update_last_version()</code>","text":"<p>Update the last version of the graph</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_metadata.py</code> <pre><code>def update_last_version(self):\n\"\"\"\n    Update the last version of the graph\n    \"\"\"\n    current_metadata = self.get_metadata()\n    if self.last_version_key in current_metadata:\n        current_version = int(self.get_last_graph_version())\n        new_version = current_version + 1\n        self.set_last_graph_version(str(new_version))\n        self.update_last_modified_date()\n    else:\n        self.set_last_graph_version(\"0\")\n        self.update_last_modified_date()\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/","title":"CosmoTech_Acceleration_Library.Modelops.core.io.model_reader","text":""},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader","title":"<code>ModelReader</code>","text":"<p>         Bases: <code>VersionedGraphHandler</code></p> <p>Model Reader for cached data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>class ModelReader(VersionedGraphHandler):\n\"\"\"\n    Model Reader for cached data\n    \"\"\"\n\n    def get_twin_types(self) -&gt; list:\n\"\"\"\n        Get twin types\n        :return: twin types list\n        \"\"\"\n        return [item for sublist in self.graph.labels() for item in sublist]\n\n    def get_twins_by_type(self, twin_type: str, limit: int = 0) -&gt; QueryResult:\n\"\"\"\n        Get twins by type\n        :param twin_type: the twin type requested\n        :param limit: the limit number of twin retrieved\n        :return: the twin list corresponding to twin type parameter\n        \"\"\"\n        twin_query = f'MATCH (node:{twin_type}) RETURN node'\n        if limit != 0:\n            twin_query = f'{twin_query} LIMIT {str(limit)}'\n        logger.debug(f\"Query : {twin_query}\")\n        return self.graph.query(twin_query, read_only=True)\n\n    def get_twin_properties_by_type(self, twin_type: str) -&gt; list:\n\"\"\"\n        Get twin properties regarding a twin_type\n        Note: this will work if all twin (with the same type) have same properties set\n        :param twin_type: the twin type\n        :return: the properties list\n        \"\"\"\n        result = []\n        twin_result = self.get_twins_by_type(twin_type, 1)\n        result_set = twin_result.result_set\n        if result_set and result_set[0]:\n            for key, val in result_set[0][0].properties.items():\n                if str(key) != ModelUtil.dt_id_key:\n                    result.append(str(key))\n                else:\n                    result.append(ModelUtil.id_key)\n        return result\n\n    def get_relationship_types(self) -&gt; list:\n\"\"\"\n        Get relationship types\n        :return: relationship types list\n        \"\"\"\n        return [item for sublist in self.graph.relationship_types() for item in sublist]\n\n    def get_relationships_by_type(self, relationship_type: str, limit: int = 0) -&gt; QueryResult:\n\"\"\"\n        Get relationships by type\n        :param relationship_type: the relationship type requested\n        :param limit: the limit number of twin retrieved\n        :return: the relationship list corresponding to relationship type parameter\n        \"\"\"\n        rel_query = f'MATCH (n)-[relation:{relationship_type}]-&gt;(m) RETURN n.{ModelUtil.dt_id_key} as {ModelUtil.source_key}, ' \\\n                    f'm.{ModelUtil.dt_id_key} as {ModelUtil.target_key}, relation'\n        if limit != 0:\n            rel_query = f'{rel_query} LIMIT {str(limit)}'\n        logger.debug(f\"Query : {rel_query}\")\n        return self.graph.query(rel_query, read_only=True)\n\n    def get_relationship_properties_by_type(self, relationship_type: str) -&gt; list:\n\"\"\"\n        Get relationship properties regarding a relationship_type\n        Note: this will work if all relationship (with the same type) have same properties set\n        :param relationship_type: the relationship type\n        :return: the properties list\n        \"\"\"\n        result = [ModelUtil.source_key, ModelUtil.target_key]\n        relationship_result = self.get_relationships_by_type(relationship_type, 1)\n        result_set = relationship_result.result_set\n        if result_set and result_set[0]:\n            # relationship\n            for key, val in result_set[0][2].properties.items():\n                if not str(key) in result:\n                    if str(key) == ModelUtil.dt_id_key:\n                        result.append(ModelUtil.id_key)\n                    elif str(key) != ModelUtil.src_key and str(key) != ModelUtil.dest_key:\n                        result.append(str(key))\n        return result\n\n    def query(self, query: str, params: dict = None, timeout: int = None, read_only: bool = False) -&gt; QueryResult:\n\"\"\"\n        Run specified query\n        :param query: the query to run\n        :param params: the parameters for the query if any\n        :param timeout: a specific timeout\n        :param read_only: executes a readonly query if set to True\n        :return: the QueryResult corresponding to specified query\n        \"\"\"\n        logger.debug(f\"Query : {query}\")\n        return self.graph.query(q=query, params=params, timeout=timeout, read_only=read_only)\n\n    def exists(self, key) -&gt; bool:\n\"\"\"\n        Check if a key exists in Redis\n        :param key: the key\n        :return: True if exists else False\n        \"\"\"\n        return False if self.r.exists(key) == 0 else True\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.exists","title":"<code>exists(key)</code>","text":"<p>Check if a key exists in Redis :param key: the key :return: True if exists else False</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def exists(self, key) -&gt; bool:\n\"\"\"\n    Check if a key exists in Redis\n    :param key: the key\n    :return: True if exists else False\n    \"\"\"\n    return False if self.r.exists(key) == 0 else True\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_relationship_properties_by_type","title":"<code>get_relationship_properties_by_type(relationship_type)</code>","text":"<p>Get relationship properties regarding a relationship_type Note: this will work if all relationship (with the same type) have same properties set :param relationship_type: the relationship type :return: the properties list</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_relationship_properties_by_type(self, relationship_type: str) -&gt; list:\n\"\"\"\n    Get relationship properties regarding a relationship_type\n    Note: this will work if all relationship (with the same type) have same properties set\n    :param relationship_type: the relationship type\n    :return: the properties list\n    \"\"\"\n    result = [ModelUtil.source_key, ModelUtil.target_key]\n    relationship_result = self.get_relationships_by_type(relationship_type, 1)\n    result_set = relationship_result.result_set\n    if result_set and result_set[0]:\n        # relationship\n        for key, val in result_set[0][2].properties.items():\n            if not str(key) in result:\n                if str(key) == ModelUtil.dt_id_key:\n                    result.append(ModelUtil.id_key)\n                elif str(key) != ModelUtil.src_key and str(key) != ModelUtil.dest_key:\n                    result.append(str(key))\n    return result\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_relationship_types","title":"<code>get_relationship_types()</code>","text":"<p>Get relationship types :return: relationship types list</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_relationship_types(self) -&gt; list:\n\"\"\"\n    Get relationship types\n    :return: relationship types list\n    \"\"\"\n    return [item for sublist in self.graph.relationship_types() for item in sublist]\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_relationships_by_type","title":"<code>get_relationships_by_type(relationship_type, limit=0)</code>","text":"<p>Get relationships by type :param relationship_type: the relationship type requested :param limit: the limit number of twin retrieved :return: the relationship list corresponding to relationship type parameter</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_relationships_by_type(self, relationship_type: str, limit: int = 0) -&gt; QueryResult:\n\"\"\"\n    Get relationships by type\n    :param relationship_type: the relationship type requested\n    :param limit: the limit number of twin retrieved\n    :return: the relationship list corresponding to relationship type parameter\n    \"\"\"\n    rel_query = f'MATCH (n)-[relation:{relationship_type}]-&gt;(m) RETURN n.{ModelUtil.dt_id_key} as {ModelUtil.source_key}, ' \\\n                f'm.{ModelUtil.dt_id_key} as {ModelUtil.target_key}, relation'\n    if limit != 0:\n        rel_query = f'{rel_query} LIMIT {str(limit)}'\n    logger.debug(f\"Query : {rel_query}\")\n    return self.graph.query(rel_query, read_only=True)\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_twin_properties_by_type","title":"<code>get_twin_properties_by_type(twin_type)</code>","text":"<p>Get twin properties regarding a twin_type Note: this will work if all twin (with the same type) have same properties set :param twin_type: the twin type :return: the properties list</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_twin_properties_by_type(self, twin_type: str) -&gt; list:\n\"\"\"\n    Get twin properties regarding a twin_type\n    Note: this will work if all twin (with the same type) have same properties set\n    :param twin_type: the twin type\n    :return: the properties list\n    \"\"\"\n    result = []\n    twin_result = self.get_twins_by_type(twin_type, 1)\n    result_set = twin_result.result_set\n    if result_set and result_set[0]:\n        for key, val in result_set[0][0].properties.items():\n            if str(key) != ModelUtil.dt_id_key:\n                result.append(str(key))\n            else:\n                result.append(ModelUtil.id_key)\n    return result\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_twin_types","title":"<code>get_twin_types()</code>","text":"<p>Get twin types :return: twin types list</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_twin_types(self) -&gt; list:\n\"\"\"\n    Get twin types\n    :return: twin types list\n    \"\"\"\n    return [item for sublist in self.graph.labels() for item in sublist]\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.get_twins_by_type","title":"<code>get_twins_by_type(twin_type, limit=0)</code>","text":"<p>Get twins by type :param twin_type: the twin type requested :param limit: the limit number of twin retrieved :return: the twin list corresponding to twin type parameter</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def get_twins_by_type(self, twin_type: str, limit: int = 0) -&gt; QueryResult:\n\"\"\"\n    Get twins by type\n    :param twin_type: the twin type requested\n    :param limit: the limit number of twin retrieved\n    :return: the twin list corresponding to twin type parameter\n    \"\"\"\n    twin_query = f'MATCH (node:{twin_type}) RETURN node'\n    if limit != 0:\n        twin_query = f'{twin_query} LIMIT {str(limit)}'\n    logger.debug(f\"Query : {twin_query}\")\n    return self.graph.query(twin_query, read_only=True)\n</code></pre>"},{"location":"references/Modelops/core/io/model_reader/#CosmoTech_Acceleration_Library.Modelops.core.io.model_reader.ModelReader.query","title":"<code>query(query, params=None, timeout=None, read_only=False)</code>","text":"<p>Run specified query :param query: the query to run :param params: the parameters for the query if any :param timeout: a specific timeout :param read_only: executes a readonly query if set to True :return: the QueryResult corresponding to specified query</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_reader.py</code> <pre><code>def query(self, query: str, params: dict = None, timeout: int = None, read_only: bool = False) -&gt; QueryResult:\n\"\"\"\n    Run specified query\n    :param query: the query to run\n    :param params: the parameters for the query if any\n    :param timeout: a specific timeout\n    :param read_only: executes a readonly query if set to True\n    :return: the QueryResult corresponding to specified query\n    \"\"\"\n    logger.debug(f\"Query : {query}\")\n    return self.graph.query(q=query, params=params, timeout=timeout, read_only=read_only)\n</code></pre>"},{"location":"references/Modelops/core/io/model_writer/","title":"CosmoTech_Acceleration_Library.Modelops.core.io.model_writer","text":""},{"location":"references/Modelops/core/io/model_writer/#CosmoTech_Acceleration_Library.Modelops.core.io.model_writer.ModelWriter","title":"<code>ModelWriter</code>","text":"<p>         Bases: <code>VersionedGraphHandler</code></p> <p>Model Writer for cached data</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_writer.py</code> <pre><code>class ModelWriter(VersionedGraphHandler):\n\"\"\"\n    Model Writer for cached data\n    \"\"\"\n\n    @update_last_modified_date\n    def create_twin(self, twin_type: str, properties: dict):\n\"\"\"\n        Create a twin\n        :param twin_type: the twin type\n        :param properties: the twin properties\n        \"\"\"\n        create_query = ModelUtil.create_twin_query(twin_type, properties)\n        logger.debug(f\"Query: {create_query}\")\n        self.graph.query(create_query)\n\n    @update_last_modified_date\n    def create_relationship(self, relationship_type: str, properties: dict):\n\"\"\"\n        Create a relationship\n        :param relationship_type: the relationship type\n        :param properties: the relationship properties\n        \"\"\"\n        create_rel = ModelUtil.create_relationship_query(relationship_type, properties)\n        logger.debug(f\"Query: {create_rel}\")\n        self.graph.query(create_rel)\n</code></pre>"},{"location":"references/Modelops/core/io/model_writer/#CosmoTech_Acceleration_Library.Modelops.core.io.model_writer.ModelWriter.create_relationship","title":"<code>create_relationship(relationship_type, properties)</code>","text":"<p>Create a relationship :param relationship_type: the relationship type :param properties: the relationship properties</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_writer.py</code> <pre><code>@update_last_modified_date\ndef create_relationship(self, relationship_type: str, properties: dict):\n\"\"\"\n    Create a relationship\n    :param relationship_type: the relationship type\n    :param properties: the relationship properties\n    \"\"\"\n    create_rel = ModelUtil.create_relationship_query(relationship_type, properties)\n    logger.debug(f\"Query: {create_rel}\")\n    self.graph.query(create_rel)\n</code></pre>"},{"location":"references/Modelops/core/io/model_writer/#CosmoTech_Acceleration_Library.Modelops.core.io.model_writer.ModelWriter.create_twin","title":"<code>create_twin(twin_type, properties)</code>","text":"<p>Create a twin :param twin_type: the twin type :param properties: the twin properties</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/io/model_writer.py</code> <pre><code>@update_last_modified_date\ndef create_twin(self, twin_type: str, properties: dict):\n\"\"\"\n    Create a twin\n    :param twin_type: the twin type\n    :param properties: the twin properties\n    \"\"\"\n    create_query = ModelUtil.create_twin_query(twin_type, properties)\n    logger.debug(f\"Query: {create_query}\")\n    self.graph.query(create_query)\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/","title":"CosmoTech_Acceleration_Library.Modelops.core.utils.model_util","text":""},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil","title":"<code>ModelUtil</code>","text":"<p>Utility class for Redis management</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>class ModelUtil:\n\"\"\"\n    Utility class for Redis management\n    \"\"\"\n\n    # ADT variables\n    source_key = 'source'\n    target_key = 'target'\n    id_key = 'id'\n\n    # Redis/Csm variables\n    src_key = 'src'\n    dest_key = 'dest'\n    dt_id_key = 'id'\n\n    @staticmethod\n    def dict_to_cypher_parameters(parameters: dict) -&gt; str:\n\"\"\"\n        Convert a dict to usable Cypher parameters object\n        :param parameters: parameters dict\n        :return: string representing parameters as Cyper Parameters\n        \"\"\"\n\n        cypher_list = []\n        for key, value in parameters.items():\n            formatted_value = stringify_param_value(value)\n            if isinstance(value, str):\n                try:\n                    json.loads(value)\n                    formatted_value = json.dumps(value)\n                except ValueError as e:\n                    logger.debug(f\"{value} is not a jsonString, use the raw value\")\n            cypher_list.append(f\"{key} : {formatted_value}\")\n        joined_list = ', '.join(cypher_list)\n        return '{' + joined_list + '}'\n\n    @staticmethod\n    def create_index_query(entity_name: str, entity_property_name: str) -&gt; str:\n\"\"\"\n        Create an index query\n        :param entity_name: the entity name on which you want to define an index\n        :param entity_property_name:  the entity property name on which you want to define an index\n        :return: the create index query\n        \"\"\"\n        return f\"CREATE INDEX ON :{entity_name}({entity_property_name})\"\n\n    @staticmethod\n    def create_twin_query(twin_type: str, properties: dict) -&gt; str:\n\"\"\"\n        Create a twin query\n        :param twin_type:the future twin name\n        :param properties: the properties of the twin\n        :return: the create twin query\n        \"\"\"\n        if ModelUtil.dt_id_key in properties:\n            cypher_params = ModelUtil.dict_to_cypher_parameters(properties)\n            return f\"CREATE (:{twin_type} {cypher_params})\"\n        raise Exception(\n            f\"When you create a twin, you should define at least {ModelUtil.dt_id_key} properties \")\n\n    @staticmethod\n    def create_relationship_query(relationship_type: str, properties: dict) -&gt; str:\n\"\"\"\n        Create a relationship query\n        :param relationship_type: the future relationship name\n        :param properties: the properties of the relationship (should contain 'src' and 'dest' properties)\n        :return: the create relationship query\n        \"\"\"\n\n        if ModelUtil.src_key in properties and ModelUtil.dest_key in properties:\n            cypher_params = ModelUtil.dict_to_cypher_parameters(properties)\n            return f\"MATCH (n), (m) WHERE n.{ModelUtil.dt_id_key} = '{properties.get(ModelUtil.src_key)}' \" \\\n                   f\"AND m.{ModelUtil.dt_id_key} = '{properties.get(ModelUtil.dest_key)}' \" \\\n                   f\"CREATE (n)-[r:{relationship_type} {cypher_params}]-&gt;(m) RETURN r\"\n        raise Exception(\n            f\"When you create a relationship, you should define at least {ModelUtil.src_key} and {ModelUtil.dest_key} properties \")\n\n    @staticmethod\n    def dict_to_json(obj: dict) -&gt; str:\n\"\"\"\n        Transform a dict to a json string\n        :param obj: the dict\n        :return: the json string corresponding\n        \"\"\"\n        return json.dumps(obj, indent=2)\n\n    @staticmethod\n    def result_set_to_json(query_result: QueryResult) -&gt; list:\n\"\"\"\n        Transform a QueryResult object to a json string list\n        :param query_result: the QueryResult object\n        :return: the json string list\n        \"\"\"\n        flattened_headers = [item for sublist in query_result.header for item in sublist]\n        headers_without_integers = [x for x in flattened_headers if not isinstance(x, int)]\n        result_list = []\n        for result in query_result.result_set:\n            result_dict = {}\n            for i in range(len(headers_without_integers)):\n                obj = result[i]\n                if isinstance(obj, Edge) or isinstance(obj, Node):\n                    result_dict[headers_without_integers[i]] = obj.properties\n                else:\n                    result_dict[headers_without_integers[i]] = obj\n            result_list.append(ModelUtil.dict_to_json(result_dict))\n        return result_list\n\n    @staticmethod\n    def print_query_result(query_result: QueryResult) -&gt; None:\n\"\"\"\n        Pretty print a QueryResult\n        :param query_result: the QueryResult to print\n        \"\"\"\n        list_to_print = ModelUtil.result_set_to_json(query_result)\n        for result in list_to_print:\n            print(result)\n\n    @staticmethod\n    def convert_datetime_to_str(date: datetime) -&gt; str:\n\"\"\"\n        Convert a datetime to a str\n        :param date: the datetime\n        :return: the string representing the datetime\n        \"\"\"\n        return date.strftime('%Y/%m/%d - %H:%M:%S')\n\n    @staticmethod\n    def convert_str_to_datetime(date_str: str) -&gt; datetime:\n\"\"\"\n        Convert a datetime to a str\n        :param date_str: the str representing a date\n        :return: the datetime corresponding to date_str\n        \"\"\"\n        date_time_obj = datetime.strptime(date_str, '%Y/%m/%d - %H:%M:%S')\n        return date_time_obj\n\n    @staticmethod\n    def build_graph_version_name(graph_name: str, version: int) -&gt; str:\n\"\"\"\n        Build versioned graph name\n        :param graph_name: the graph name\n        :param version: the version\n        :return: the versioned graph name\n        \"\"\"\n        return graph_name + \":\" + str(version)\n\n    @staticmethod\n    def build_graph_key_pattern(graph_name: str) -&gt; str:\n        return graph_name + \":*\"\n\n    @staticmethod\n    def unjsonify(value: dict) -&gt; dict:\n\"\"\"\n        Unjsonify transform json strings to python objects\n        :param value a dict\n        :return: a dict with unjsonify values\n        \"\"\"\n        for k, v in value.items():\n            if isinstance(v, str):\n                try:\n                    value[k] = json.loads(v)\n                    logger.debug(f\" new value =&gt; {value[k]}\")\n                except ValueError as e:\n                    logger.debug(f\"{v} is not a jsonString, use the raw value\")\n        return value\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.build_graph_version_name","title":"<code>build_graph_version_name(graph_name, version)</code>  <code>staticmethod</code>","text":"<p>Build versioned graph name :param graph_name: the graph name :param version: the version :return: the versioned graph name</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef build_graph_version_name(graph_name: str, version: int) -&gt; str:\n\"\"\"\n    Build versioned graph name\n    :param graph_name: the graph name\n    :param version: the version\n    :return: the versioned graph name\n    \"\"\"\n    return graph_name + \":\" + str(version)\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.convert_datetime_to_str","title":"<code>convert_datetime_to_str(date)</code>  <code>staticmethod</code>","text":"<p>Convert a datetime to a str :param date: the datetime :return: the string representing the datetime</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef convert_datetime_to_str(date: datetime) -&gt; str:\n\"\"\"\n    Convert a datetime to a str\n    :param date: the datetime\n    :return: the string representing the datetime\n    \"\"\"\n    return date.strftime('%Y/%m/%d - %H:%M:%S')\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.convert_str_to_datetime","title":"<code>convert_str_to_datetime(date_str)</code>  <code>staticmethod</code>","text":"<p>Convert a datetime to a str :param date_str: the str representing a date :return: the datetime corresponding to date_str</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef convert_str_to_datetime(date_str: str) -&gt; datetime:\n\"\"\"\n    Convert a datetime to a str\n    :param date_str: the str representing a date\n    :return: the datetime corresponding to date_str\n    \"\"\"\n    date_time_obj = datetime.strptime(date_str, '%Y/%m/%d - %H:%M:%S')\n    return date_time_obj\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.create_index_query","title":"<code>create_index_query(entity_name, entity_property_name)</code>  <code>staticmethod</code>","text":"<p>Create an index query :param entity_name: the entity name on which you want to define an index :param entity_property_name:  the entity property name on which you want to define an index :return: the create index query</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef create_index_query(entity_name: str, entity_property_name: str) -&gt; str:\n\"\"\"\n    Create an index query\n    :param entity_name: the entity name on which you want to define an index\n    :param entity_property_name:  the entity property name on which you want to define an index\n    :return: the create index query\n    \"\"\"\n    return f\"CREATE INDEX ON :{entity_name}({entity_property_name})\"\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.create_relationship_query","title":"<code>create_relationship_query(relationship_type, properties)</code>  <code>staticmethod</code>","text":"<p>Create a relationship query :param relationship_type: the future relationship name :param properties: the properties of the relationship (should contain 'src' and 'dest' properties) :return: the create relationship query</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef create_relationship_query(relationship_type: str, properties: dict) -&gt; str:\n\"\"\"\n    Create a relationship query\n    :param relationship_type: the future relationship name\n    :param properties: the properties of the relationship (should contain 'src' and 'dest' properties)\n    :return: the create relationship query\n    \"\"\"\n\n    if ModelUtil.src_key in properties and ModelUtil.dest_key in properties:\n        cypher_params = ModelUtil.dict_to_cypher_parameters(properties)\n        return f\"MATCH (n), (m) WHERE n.{ModelUtil.dt_id_key} = '{properties.get(ModelUtil.src_key)}' \" \\\n               f\"AND m.{ModelUtil.dt_id_key} = '{properties.get(ModelUtil.dest_key)}' \" \\\n               f\"CREATE (n)-[r:{relationship_type} {cypher_params}]-&gt;(m) RETURN r\"\n    raise Exception(\n        f\"When you create a relationship, you should define at least {ModelUtil.src_key} and {ModelUtil.dest_key} properties \")\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.create_twin_query","title":"<code>create_twin_query(twin_type, properties)</code>  <code>staticmethod</code>","text":"<p>Create a twin query :param twin_type:the future twin name :param properties: the properties of the twin :return: the create twin query</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef create_twin_query(twin_type: str, properties: dict) -&gt; str:\n\"\"\"\n    Create a twin query\n    :param twin_type:the future twin name\n    :param properties: the properties of the twin\n    :return: the create twin query\n    \"\"\"\n    if ModelUtil.dt_id_key in properties:\n        cypher_params = ModelUtil.dict_to_cypher_parameters(properties)\n        return f\"CREATE (:{twin_type} {cypher_params})\"\n    raise Exception(\n        f\"When you create a twin, you should define at least {ModelUtil.dt_id_key} properties \")\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.dict_to_cypher_parameters","title":"<code>dict_to_cypher_parameters(parameters)</code>  <code>staticmethod</code>","text":"<p>Convert a dict to usable Cypher parameters object :param parameters: parameters dict :return: string representing parameters as Cyper Parameters</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef dict_to_cypher_parameters(parameters: dict) -&gt; str:\n\"\"\"\n    Convert a dict to usable Cypher parameters object\n    :param parameters: parameters dict\n    :return: string representing parameters as Cyper Parameters\n    \"\"\"\n\n    cypher_list = []\n    for key, value in parameters.items():\n        formatted_value = stringify_param_value(value)\n        if isinstance(value, str):\n            try:\n                json.loads(value)\n                formatted_value = json.dumps(value)\n            except ValueError as e:\n                logger.debug(f\"{value} is not a jsonString, use the raw value\")\n        cypher_list.append(f\"{key} : {formatted_value}\")\n    joined_list = ', '.join(cypher_list)\n    return '{' + joined_list + '}'\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.dict_to_json","title":"<code>dict_to_json(obj)</code>  <code>staticmethod</code>","text":"<p>Transform a dict to a json string :param obj: the dict :return: the json string corresponding</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef dict_to_json(obj: dict) -&gt; str:\n\"\"\"\n    Transform a dict to a json string\n    :param obj: the dict\n    :return: the json string corresponding\n    \"\"\"\n    return json.dumps(obj, indent=2)\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.print_query_result","title":"<code>print_query_result(query_result)</code>  <code>staticmethod</code>","text":"<p>Pretty print a QueryResult :param query_result: the QueryResult to print</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef print_query_result(query_result: QueryResult) -&gt; None:\n\"\"\"\n    Pretty print a QueryResult\n    :param query_result: the QueryResult to print\n    \"\"\"\n    list_to_print = ModelUtil.result_set_to_json(query_result)\n    for result in list_to_print:\n        print(result)\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.result_set_to_json","title":"<code>result_set_to_json(query_result)</code>  <code>staticmethod</code>","text":"<p>Transform a QueryResult object to a json string list :param query_result: the QueryResult object :return: the json string list</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef result_set_to_json(query_result: QueryResult) -&gt; list:\n\"\"\"\n    Transform a QueryResult object to a json string list\n    :param query_result: the QueryResult object\n    :return: the json string list\n    \"\"\"\n    flattened_headers = [item for sublist in query_result.header for item in sublist]\n    headers_without_integers = [x for x in flattened_headers if not isinstance(x, int)]\n    result_list = []\n    for result in query_result.result_set:\n        result_dict = {}\n        for i in range(len(headers_without_integers)):\n            obj = result[i]\n            if isinstance(obj, Edge) or isinstance(obj, Node):\n                result_dict[headers_without_integers[i]] = obj.properties\n            else:\n                result_dict[headers_without_integers[i]] = obj\n        result_list.append(ModelUtil.dict_to_json(result_dict))\n    return result_list\n</code></pre>"},{"location":"references/Modelops/core/utils/model_util/#CosmoTech_Acceleration_Library.Modelops.core.utils.model_util.ModelUtil.unjsonify","title":"<code>unjsonify(value)</code>  <code>staticmethod</code>","text":"<p>Unjsonify transform json strings to python objects :param value a dict :return: a dict with unjsonify values</p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/model_util.py</code> <pre><code>@staticmethod\ndef unjsonify(value: dict) -&gt; dict:\n\"\"\"\n    Unjsonify transform json strings to python objects\n    :param value a dict\n    :return: a dict with unjsonify values\n    \"\"\"\n    for k, v in value.items():\n        if isinstance(v, str):\n            try:\n                value[k] = json.loads(v)\n                logger.debug(f\" new value =&gt; {value[k]}\")\n            except ValueError as e:\n                logger.debug(f\"{v} is not a jsonString, use the raw value\")\n    return value\n</code></pre>"},{"location":"references/Modelops/core/utils/tests/model_util_test/","title":"CosmoTech_Acceleration_Library.Modelops.core.utils.tests.model_util_test","text":""},{"location":"references/Modelops/core/utils/tests/model_util_test/#CosmoTech_Acceleration_Library.Modelops.core.utils.tests.model_util_test.TestModelUtil","title":"<code>TestModelUtil</code>","text":"<p>         Bases: <code>unittest.TestCase</code></p> Source code in <code>CosmoTech_Acceleration_Library/Modelops/core/utils/tests/model_util_test.py</code> <pre><code>class TestModelUtil(unittest.TestCase):\n    # Global variables\n    simple_parameters = {\n        \"id\": \"Twin1\",\n        \"brand\": \"Ford\",\n        \"electric\": False,\n        \"year\": 1964,\n        \"dict_param\": {\n            \"property1\": \"toto\",\n            \"property2\": \"tata\",\n        },\n        \"with_quotes\": \"'9999'\",\n        \"with_dbl_quotes\": '\"1234\"',\n        \"colors\": [\"red\", \"white\", \"blue\"]\n    }\n\n    relationship_simple_parameters = {\n        \"src\": \"Node1\",\n        \"dest\": \"Node2\",\n        \"brand\": \"Ford\",\n        \"electric\": False,\n        \"year\": 1964,\n        \"dict_param\": {\n            \"property1\": \"toto\",\n            \"property2\": \"tata\",\n        },\n        \"with_quotes\": \"'12345'\",\n        \"colors\": [\"red\", \"white\", \"blue\"]\n    }\n\n    dict_with_simple_json_string = {\n        \"src\": \"Node1\",\n        \"dest\": \"Node2\",\n        \"brand\": \"Ford\",\n        \"electric\": False,\n        \"year\": 1964,\n        \"dict_param\": \"{\\\"property1\\\": \\\"toto\\\", \\\"property2\\\": \\\"tata\\\"}\",\n        \"with_quotes\": \"'12345'\",\n        \"colors\": [\"red\", \"white\", \"blue\"]\n    }\n\n    expected_simple_parameters = '{id : \"Twin1\", ' \\\n                                 'brand : \"Ford\", ' \\\n                                 'electric : False, ' \\\n                                 'year : 1964, ' \\\n                                 'dict_param : {property1:\\\"toto\\\",property2:\\\"tata\\\"}, ' \\\n                                 'with_quotes : \"\\'9999\\'\", ' \\\n                                 'with_dbl_quotes : \"\\\\\"1234\\\\\"\", ' \\\n                                 'colors : [\"red\",\"white\",\"blue\"]}'\n\n    expected_relationship_simple_parameters = '{src : \"Node1\", ' \\\n                                              'dest : \"Node2\", ' \\\n                                              'brand : \"Ford\", ' \\\n                                              'electric : False, ' \\\n                                              'year : 1964, ' \\\n                                              'dict_param : {property1:\\\"toto\\\",property2:\\\"tata\\\"}, ' \\\n                                              'with_quotes : \"\\'12345\\'\", ' \\\n                                              'colors : [\"red\",\"white\",\"blue\"]}'\n\n    def setUp(self):\n        self.model_util = ModelUtil()\n\n    def test_dict_to_cypher_parameters_with_simple_parameters(self):\n        self.assertEqual(self.expected_simple_parameters,\n                         self.model_util.dict_to_cypher_parameters(self.simple_parameters))\n\n    def test_create_index_query(self):\n        expected_result = \"CREATE INDEX ON :Entity_Test(property_name_test)\"\n        self.assertEqual(expected_result, self.model_util.create_index_query(\"Entity_Test\", \"property_name_test\"))\n\n    def test_create_twin_query(self):\n        expected_result = f\"CREATE (:Entity_Test {self.expected_simple_parameters})\"\n        self.assertEqual(expected_result, self.model_util.create_twin_query(\"Entity_Test\", self.simple_parameters))\n\n    def test_create_twin_query_Exception(self):\n        twin_name = 'Twin_name'\n        self.assertRaises(Exception,\n                          self.model_util.create_twin_query, twin_name, self.expected_simple_parameters)\n\n    def test_create_relationship_query(self):\n        source_id = 'Node1'\n        destination_id = 'Node2'\n        relation_name = 'Relation_Name'\n        expected_result = f\"MATCH (n), (m) WHERE n.{ModelUtil.dt_id_key} = '{source_id}' AND m.{ModelUtil.dt_id_key} = '{destination_id}' CREATE (n)-[r:{relation_name} {self.expected_relationship_simple_parameters}]-&gt;(m) RETURN r\"\n        self.assertEqual(expected_result,\n                         self.model_util.create_relationship_query(relation_name, self.relationship_simple_parameters))\n\n    def test_create_relationship_query_Exception(self):\n        relation_name = 'Relation_Name'\n        self.assertRaises(Exception,\n                          self.model_util.create_relationship_query, relation_name, self.expected_simple_parameters)\n\n    def test_unjsonify_without_jsonstring(self):\n        new_value = self.model_util.unjsonify(self.relationship_simple_parameters)\n        self.assertEqual(self.relationship_simple_parameters, new_value)\n\n    def test_unjsonify_with_jsonstring(self):\n        new_value = self.model_util.unjsonify(self.dict_with_simple_json_string)\n        self.assertEqual(self.relationship_simple_parameters, new_value)\n</code></pre>"}]}